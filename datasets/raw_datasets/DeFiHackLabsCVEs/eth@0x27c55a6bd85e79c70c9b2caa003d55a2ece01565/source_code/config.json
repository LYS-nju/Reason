{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CurveContractInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface CurveContractInterface {\\r\\n    // Functions in interfaces must be declared external,\\r\\n    // function QueryAddressProvider(uint id) virtual internal view returns (address);\\r\\n//    function QueryPoolInfo(address pool) virtual external view;\\r\\n//    function QueryChangeRate(address _from, address _to, uint _dx) virtual external view returns (uint256);\\r\\n    //function setAddresses(address depoAddr_, address leveAddr_) external;\\r\\n    //function changeUSDT2USDC(uint _amount, uint _expected, address _receiver) external returns (uint256);\\r\\n    //function changeUSDC2USDT(uint _amount, uint _expected, address _receiver) external returns (uint256);\\r\\n    //function PerformExchange(address _from, address _to, uint _amount, uint _expected, address _receiver) external returns (uint256);\\r\\n    // approveToken is a public func\\r\\n    // function approveToken(address token, address spender, uint _amount) virtual public returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/CurveSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { ICurveFi } from \\\"./vendor/interfaces/ICurveFi.sol\\\";\\r\\nimport { IRegistry } from \\\"./vendor/interfaces/IRegistry.sol\\\";\\r\\nimport { IAddressProvider } from \\\"./vendor/interfaces/IAddressProvider.sol\\\";\\r\\nimport { IERC20 } from \\\"./vendor/interfaces/IERC20.sol\\\";\\r\\nimport { SafeERC20 } from \\\"./vendor/interfaces/SafeERC20.sol\\\";\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\nimport \\\"./CurveContractInterface.sol\\\";\\r\\n\\r\\ncontract CurveSwap is CurveContractInterface{\\r\\n    using SafeERC20 for IERC20;\\r\\n    address public TriPool;\\r\\n    address public ADDRESSPROVIDER;\\r\\n    address public USDC_ADDRESS;\\r\\n    address public USDT_ADDRESS;\\r\\n\\r\\n    function setAddressesCurve(address TriPool_, address ADDRESSPROVIDER_, address USDC_ADDRESS_, address USDT_ADDRESS_) internal {\\r\\n//        TriPool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\\r\\n//        ADDRESSPROVIDER = 0x0000000022D53366457F9d5E68Ec105046FC4383;\\r\\n//        USDC_ADDRESS = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\r\\n//        USDT_ADDRESS = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\r\\n        TriPool = TriPool_;\\r\\n        ADDRESSPROVIDER = ADDRESSPROVIDER_;\\r\\n        USDC_ADDRESS = USDC_ADDRESS_;\\r\\n        USDT_ADDRESS = USDT_ADDRESS_;\\r\\n    }\\r\\n\\r\\n    function QueryAddressProvider(uint id) internal view returns (address) {\\r\\n        return IAddressProvider(ADDRESSPROVIDER).get_address(id);\\r\\n    }\\r\\n\\r\\n//    function QueryChangeRate(address _from, address _to, uint _dx) external view returns (uint256) {\\r\\n//        address Registry = QueryAddressProvider(2);\\r\\n//        uint dy = IRegistry(Registry).get_exchange_amount(TriPool, _from, _to, _dx);\\r\\n//        return dy;\\r\\n//    }\\r\\n\\r\\n    function PerformExchange(address _from, address _to, uint _amount, uint _expected, address _receiver) internal returns (uint256) {\\r\\n        address Registry = QueryAddressProvider(2);\\r\\n        uint receToken = IRegistry(Registry).exchange(TriPool, _from, _to, _amount, _expected, _receiver);\\r\\n        return receToken;\\r\\n    }\\r\\n\\r\\n    function changeUSDT2USDC(uint _amount, uint _expected, address _receiver) virtual internal returns (uint256) {\\r\\n        address Registry = QueryAddressProvider(2);\\r\\n        approveToken(USDT_ADDRESS, Registry, _amount);\\r\\n        uint receToken = IRegistry(Registry).exchange(TriPool, USDT_ADDRESS, USDC_ADDRESS, _amount, _expected, _receiver);\\r\\n        return receToken;\\r\\n    }\\r\\n\\r\\n    function changeUSDC2USDT(uint _amount, uint _expected, address _receiver) internal returns (uint256) {\\r\\n        address Registry = QueryAddressProvider(2);\\r\\n        approveToken(USDC_ADDRESS, Registry, _amount);\\r\\n        uint receToken = IRegistry(Registry).exchange(TriPool, USDC_ADDRESS, USDT_ADDRESS, _amount, _expected, _receiver);\\r\\n        return receToken;\\r\\n    }\\r\\n\\r\\n    function approveToken(address token, address spender, uint _amount) public returns (bool) {\\r\\n        IERC20(token).safeApprove(spender, _amount);\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/DepositWithdraw.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\nimport \\\"./EIP20NonStandardInterface.sol\\\";\\r\\nimport \\\"./DepositWithdrawInterface.sol\\\";\\r\\nimport { IERC20 } from \\\"./vendor/interfaces/IERC20.sol\\\";\\r\\nimport { SafeERC20 } from \\\"./vendor/interfaces/SafeERC20.sol\\\";\\r\\n\\r\\ncontract DepositWithdraw is DepositWithdrawInterface {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    address internal compoundV2cUSDCAddress;\\r\\n    address internal compoundV2cUSDTAddress;\\r\\n    address internal USDCAddress;\\r\\n    address internal USDTAddress;\\r\\n\\r\\n    function setAddresses(address compoundV2cUSDCAddress_, address compoundV2cUSDTAddress_, address USDCAddress_, address USDTAddress_) internal {\\r\\n        compoundV2cUSDCAddress = compoundV2cUSDCAddress_;\\r\\n        compoundV2cUSDTAddress = compoundV2cUSDTAddress_;\\r\\n        USDCAddress = USDCAddress_;\\r\\n        USDTAddress = USDTAddress_;\\r\\n    }\\r\\n\\r\\n    function getCUSDTNumber() internal view returns (uint) {\\r\\n        uint value = ICompoundV2(compoundV2cUSDTAddress).balanceOf(address(this));\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    function getCmpUSDTExchRate() public virtual view returns (uint) {\\r\\n        uint value = ICompoundV2(compoundV2cUSDTAddress).exchangeRateStored();\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    function getCUSDCNumber() internal view returns (uint) {\\r\\n        uint value = ICompoundV2(compoundV2cUSDCAddress).balanceOf(address(this));\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    function getCmpUSDCExchRate() internal view returns (uint) {\\r\\n        uint value = ICompoundV2(compoundV2cUSDCAddress).exchangeRateStored();\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    /*function getCmpUSDTBorrowRate() public view returns (uint) {\\r\\n        return ICompoundV2(compoundV2cUSDTAddress).borrowRatePerBlock();\\r\\n    }*/\\r\\n\\r\\n    function getCmpUSDTSupplyRate() virtual public view returns (uint) {\\r\\n        return ICompoundV2(compoundV2cUSDTAddress).supplyRatePerBlock();\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Supply USDC that this contract holds to Compound V2\\r\\n     */\\r\\n    function supplyUSDC(uint amount) internal {\\r\\n        IERC20(USDCAddress).safeApprove(compoundV2cUSDCAddress, amount);\\r\\n        ICompoundV2(compoundV2cUSDCAddress).mint(amount);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Withdraws cUSDC from Compound V2 to this contract\\r\\n     */\\r\\n    function withdrawcUSDC(uint amount) internal {\\r\\n        ICompoundV2(compoundV2cUSDCAddress).redeem(amount);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Withdraws USDC from Compound V2 to this contract\\r\\n     */\\r\\n    function withdrawUSDCfromCmp(uint amount) internal {\\r\\n        ICompoundV2(compoundV2cUSDCAddress).redeemUnderlying(amount);\\r\\n    }   \\r\\n\\r\\n    /*\\r\\n     * Supply USDT that this contract holds to Compound V2\\r\\n     */\\r\\n    function supplyUSDT2Cmp(uint amount) internal {\\r\\n        IERC20(USDTAddress).safeApprove(compoundV2cUSDTAddress, amount);\\r\\n        ICompoundV2(compoundV2cUSDTAddress).mint(amount);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Withdraws cUSDT from Compound V2 to this contract\\r\\n     */\\r\\n    function withdrawcUSDT(uint amount) internal {\\r\\n        ICompoundV2(compoundV2cUSDTAddress).redeem(amount);\\r\\n    }   \\r\\n\\r\\n    /*\\r\\n     * Withdraws USDT from Compound V2 to this contract\\r\\n     */\\r\\n    function withdrawUSDTfromCmp(uint amount) internal {\\r\\n        ICompoundV2(compoundV2cUSDTAddress).redeemUnderlying(amount);\\r\\n    }    \\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/DepositWithdrawInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\nimport \\\"./EIP20NonStandardInterface.sol\\\";\\r\\n\\r\\ninterface ICompoundV2 {\\r\\n    function mint(uint mintAmount) external returns (uint);\\r\\n    function redeem(uint redeemTokens) external returns (uint);\\r\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n    function borrowRatePerBlock() external view returns (uint);\\r\\n    function supplyRatePerBlock() external view returns (uint);\\r\\n    function exchangeRateStored() external view returns (uint);\\r\\n}\\r\\n\\r\\ninterface INNERIERC20 {\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface DepositWithdrawInterface {\\r\\n\\r\\n    //function setAddresses(address depoAddr_, address leveAddr_) external;\\r\\n    //function getCUSDTNumber() external view returns (uint);\\r\\n    //function getCmpUSDTBalance() external view returns (uint);\\r\\n    //function getCUSDCNumber() external view returns (uint);\\r\\n    //function getCmpUSDCBalance() external view returns (uint);\\r\\n    //function supplyUSDC(uint amount) external;\\r\\n    //function withdrawcUSDC(uint amount) external;\\r\\n    //function supplyUSDT2Cmp(uint amount) external;\\r\\n    //function withdrawcUSDT(uint amount) external;\\r\\n    //function withdrawUSDTfromCmp(uint amount) external;\\r\\n    //function getCmpUSDTBorrowRate() external view returns (uint);\\r\\n    //function getUSDTSupplyRate() external view returns (uint);\\r\\n}\"\r\n    },\r\n    \"contracts/DepTokenInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"./MatrixpricerInterface.sol\\\";\\r\\nimport \\\"./InterestRateModel.sol\\\";\\r\\nimport \\\"./LevTokenInterfaces.sol\\\";\\r\\nimport \\\"./EIP20NonStandardInterface.sol\\\";\\r\\nimport \\\"./ErrorReporter.sol\\\";\\r\\n// import \\\"./DepositWithdraw.sol\\\";\\r\\n\\r\\ncontract DepTokenStorage {\\r\\n    //uint internal constant MAXGAS = 0;\\r\\n    /**\\r\\n     * @dev protection against contract calling itself (re-entrancy check)\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token name for this token\\r\\n     */\\r\\n    string public name;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token symbol for this token\\r\\n     */\\r\\n    string public symbol;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token decimals for this token, we use 6 to stay consistent with usdt\\r\\n     */\\r\\n    uint8 public decimals;\\r\\n\\r\\n    // Maximum fraction of interest that can be set aside for reserves\\r\\n    uint internal constant reserveFactorMaxMantissa = 1e18;\\r\\n\\r\\n    /**\\r\\n     * @notice Administrator for this contract\\r\\n     */\\r\\n    address payable public admin;\\r\\n\\r\\n    /**\\r\\n     * @notice Pending administrator for this contract\\r\\n     */\\r\\n    address payable public pendingAdmin;\\r\\n\\r\\n    /**\\r\\n     * @notice the brain of this contract\\r\\n     */\\r\\n    MatrixpricerInterface public matrixpricer;\\r\\n\\r\\n    /**\\r\\n     * @notice Model that computes deposit and lending rate\\r\\n     */\\r\\n    InterestRateModel public interestRateModel;\\r\\n\\r\\n    /**\\r\\n     * @notice associated levErc20\\r\\n     */\\r\\n    LevErc20Interface public levErc20;\\r\\n\\r\\n    // when totalSupply = 0, need to initialise an exchangeRate\\r\\n    uint internal initialExchangeRateMantissa;  // 1e18\\r\\n\\r\\n    /**\\r\\n     * @notice Fraction of interest currently set aside for reserves\\r\\n     */\\r\\n    uint public reserveFactorMantissa;  //1e18\\r\\n\\r\\n    /**\\r\\n     * @notice Block number that interest was last accrued at\\r\\n     */\\r\\n    uint public accrualBlockNumber;\\r\\n\\r\\n    /**\\r\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\r\\n     */\\r\\n    uint public borrowIndex;\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\r\\n     */\\r\\n    uint public totalBorrows;   // decimals = 6, same as underlying(=usdt)\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of reserves of the underlying held in this market\\r\\n     */\\r\\n    uint public totalReserves;   // decimals = 6, same as underlying(=usdt)\\r\\n\\r\\n    /**\\r\\n     * @notice Total number of tokens in circulation\\r\\n     */\\r\\n    uint public totalSupply;    // decimals = 6\\r\\n\\r\\n    // Official record of token balances for each account\\r\\n    mapping (address => uint) internal accountTokens;\\r\\n\\r\\n    // Approved token transfer amounts on behalf of others\\r\\n    mapping (address => mapping (address => uint)) internal transferAllowances;\\r\\n\\r\\n    // usdt decimals is 6\\r\\n    uint internal constant minTransferAmtUSDT = 50000e6;\\r\\n    uint internal constant thresholdUSDT = 300000e6;\\r\\n    uint internal constant extraUSDT = 100000e6;\\r\\n\\r\\n    /**\\r\\n     * @notice Container for borrow balance information\\r\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\r\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\r\\n     */\\r\\n    struct BorrowSnapshot {\\r\\n        uint principal;\\r\\n        uint interestIndex;\\r\\n    }\\r\\n\\r\\n    // Mapping of account addresses to outstanding borrow balances\\r\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\r\\n\\r\\n    /**\\r\\n     * @notice Share of seized collateral that is added to reserves\\r\\n     */\\r\\n    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\\r\\n}\\r\\n\\r\\nabstract contract DepTokenInterface is DepTokenStorage {\\r\\n    /**\\r\\n     * @notice Indicator that this is a DepToken contract (for inspection)\\r\\n     */\\r\\n    bool public constant isDepToken = true;\\r\\n\\r\\n\\r\\n    /*** Market Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when interest is accrued\\r\\n     */\\r\\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are minted\\r\\n     */\\r\\n    event Mint(address minter, uint mintAmount, uint mintTokens, uint apy);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are redeemed\\r\\n     */\\r\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens, uint apy);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when underlying is borrowed\\r\\n     */\\r\\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when a borrow is repaid\\r\\n     */\\r\\n    event RepayBorrow(address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows, bool liquidate);\\r\\n\\r\\n    /*** Admin Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingAdmin is changed\\r\\n     */\\r\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\r\\n     */\\r\\n    event NewAdmin(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when matrixpricer is changed\\r\\n     */\\r\\n    event NewMatrixpricer(MatrixpricerInterface oldMatrixpricer, MatrixpricerInterface newMatrixpricer);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when interestRateModel is changed\\r\\n     */\\r\\n    //event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserve factor is changed\\r\\n     */\\r\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserves are added\\r\\n     */\\r\\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserves are reduced\\r\\n     */\\r\\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Transfer event\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint amount);\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Approval event\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\r\\n\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function transfer(address dst, uint amount) virtual external returns (bool);\\r\\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\\r\\n    function approve(address spender, uint amount) virtual external returns (bool);\\r\\n    function allowance(address owner, address spender) virtual external view returns (uint);\\r\\n    function balanceOf(address owner) virtual external view returns (uint);\\r\\n    function balanceOfUnderlying(address owner) virtual external returns (uint);\\r\\n    function balanceOfUnderlyingView(address owner) virtual external view returns (uint);\\r\\n    function getAccountSnapshot(address account) virtual external view returns (uint, uint, uint, uint);\\r\\n    function borrowRatePerBlock() virtual external view returns (uint);\\r\\n    function supplyRatePerBlock() virtual public view returns (uint);\\r\\n    function totalBorrowsCurrent() virtual external returns (uint);\\r\\n    //function borrowBalanceCurrent(address account) virtual external returns (uint);\\r\\n    //function borrowBalanceStored(address account) virtual internal view returns (uint);\\r\\n    function exchangeRateCurrent() virtual external returns (uint);\\r\\n    function exchangeRateStored() virtual external view returns (uint);\\r\\n    function getCash() virtual external view returns (uint);\\r\\n    function getCompoundBalance() virtual external view returns (uint);\\r\\n    function accrueInterest() virtual external returns (uint);\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);\\r\\n    function _acceptAdmin() virtual external returns (uint);\\r\\n    function _setMatrixpricer(MatrixpricerInterface newMatrixpricer) virtual external returns (uint);\\r\\n    function _setReserveFactor(uint newReserveFactorMantissa) virtual external returns (uint);\\r\\n    function _reduceReserves(uint reduceAmount) virtual external returns (uint);\\r\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) virtual external returns (uint);\\r\\n}\\r\\n\\r\\ncontract DepErc20Storage {\\r\\n    /**\\r\\n     * @notice Underlying asset for this DepToken\\r\\n     */\\r\\n    address public underlying;\\r\\n}\\r\\n\\r\\nabstract contract DepErc20Interface is DepErc20Storage {\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function mint(uint mintAmount) virtual external returns (uint);\\r\\n    function redeem(uint redeemTokens, uint redeemAmount) virtual external returns (uint);\\r\\n    function borrow(uint borrowAmount) virtual external returns (uint);\\r\\n    function repayBorrow(uint repayAmount, bool liquidate) virtual external returns (uint);\\r\\n    function getUnborrowedUSDTBalance() virtual external view returns (uint);\\r\\n    function getTotalBorrows() virtual external view returns (uint);    // only 1 borrower\\r\\n    function getTotalBorrowsAfterAccrueInterest() virtual external returns (uint);    // only 1 borrower\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _addReserves(uint addAmount) virtual external returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/EIP20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n * @title ERC 20 Token Standard Interface\\r\\n *  https://eips.ethereum.org/EIPS/eip-20\\r\\n */\\r\\ninterface EIP20Interface {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n      * @notice Get the total number of tokens in circulation\\r\\n      * @return The supply of tokens\\r\\n      */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the balance of the specified address\\r\\n     * @param owner The address from which the balance will be retrieved\\r\\n     * @return balance The balance\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      * @return success Whether or not the transfer succeeded\\r\\n      */\\r\\n    function transfer(address dst, uint256 amount) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n      * @param src The address of the source account\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      * @return success Whether or not the transfer succeeded\\r\\n      */\\r\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n      * @dev This will overwrite the approval amount for `spender`\\r\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\r\\n      * @return success Whether or not the approval succeeded\\r\\n      */\\r\\n    function approve(address spender, uint256 amount) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n      * @notice Get the current allowance from `owner` for `spender`\\r\\n      * @param owner The address of the account which owns the tokens to be spent\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\\r\\n      */\\r\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/EIP20NonStandardInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n * @title EIP20NonStandardInterface\\r\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\r\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n */\\r\\ninterface EIP20NonStandardInterface {\\r\\n\\r\\n    /**\\r\\n     * @notice Get the total number of tokens in circulation\\r\\n     * @return The supply of tokens\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the balance of the specified address\\r\\n     * @param owner The address from which the balance will be retrieved\\r\\n     * @return balance The balance\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      */\\r\\n    function transfer(address dst, uint256 amount) external;\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n      * @param src The address of the source account\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      */\\r\\n    function transferFrom(address src, address dst, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n      * @dev This will overwrite the approval amount for `spender`\\r\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @param amount The number of tokens that are approved\\r\\n      * @return success Whether or not the approval succeeded\\r\\n      */\\r\\n    function approve(address spender, uint256 amount) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n      * @notice Get the current allowance from `owner` for `spender`\\r\\n      * @param owner The address of the account which owns the tokens to be spent\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @return remaining The number of tokens allowed to be spent\\r\\n      */\\r\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/ErrorReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\ncontract managerErrorReporter {\\r\\n    enum Error {\\r\\n        NO_ERROR,\\r\\n        UNAUTHORIZED,\\r\\n        MATRIXPRICER_MISMATCH,\\r\\n        INSUFFICIENT_SHORTFALL,\\r\\n        INSUFFICIENT_LIQUIDITY,\\r\\n        INVALID_CLOSE_FACTOR,\\r\\n        INVALID_COLLATERAL_FACTOR,\\r\\n        INVALID_LIQUIDATION_INCENTIVE,\\r\\n        MARKET_NOT_ENTERED, // no longer possible\\r\\n        MARKET_NOT_LISTED,\\r\\n        MARKET_ALREADY_LISTED,\\r\\n        MATH_ERROR,\\r\\n        NONZERO_BORROW_BALANCE,\\r\\n        PRICE_ERROR,\\r\\n        REJECTION,\\r\\n        SNAPSHOT_ERROR,\\r\\n        TOO_MANY_ASSETS,\\r\\n        TOO_MUCH_REPAY\\r\\n    }\\r\\n\\r\\n    enum FailureInfo {\\r\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\r\\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\r\\n        EXIT_MARKET_BALANCE_OWED,\\r\\n        EXIT_MARKET_REJECTION,\\r\\n        SET_CLOSE_FACTOR_OWNER_CHECK,\\r\\n        SET_CLOSE_FACTOR_VALIDATION,\\r\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\r\\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\\r\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\r\\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\r\\n        SET_IMPLEMENTATION_OWNER_CHECK,\\r\\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\r\\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\\r\\n        SET_MAX_ASSETS_OWNER_CHECK,\\r\\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\\r\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\r\\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\r\\n        SET_PRICE_ORACLE_OWNER_CHECK,\\r\\n        SUPPORT_MARKET_EXISTS,\\r\\n        SUPPORT_MARKET_OWNER_CHECK\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\r\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\r\\n      **/\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\r\\n      */\\r\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), 0);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\r\\n      */\\r\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), opaqueError);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract TokenErrorReporter {\\r\\n    uint public constant NO_ERROR = 0; // support legacy return codes\\r\\n\\r\\n    error TransferMatrixpricerRejection(uint256 errorCode);\\r\\n    error TransferTensorpricerRejection(uint256 errorCode);\\r\\n    error TransferNotAllowed();\\r\\n    error TransferNotEnough();\\r\\n    error TransferNotEnoughAllowance();\\r\\n    error TransferTooMuch();\\r\\n\\r\\n    error MintMatrixpricerRejection(uint256 errorCode);\\r\\n    error MintTensorpricerRejection(uint256 errorCode);\\r\\n    error MintFreshnessCheck();\\r\\n\\r\\n    error RedeemMatrixpricerRejection(uint256 errorCode);\\r\\n    error RedeemTensorpricerRejection(uint256 errorCode);\\r\\n    error RedeemFreshnessCheck();\\r\\n    error RedeemTransferOutNotPossible();\\r\\n\\r\\n    error BorrowMatrixpricerRejection(uint256 errorCode);\\r\\n    error BorrowFreshnessCheck();\\r\\n    error BorrowCashNotAvailable();\\r\\n\\r\\n    error RepayBorrowMatrixpricerRejection(uint256 errorCode);\\r\\n    error RepayBorrowFreshnessCheck();\\r\\n\\r\\n    error LiquidateMatrixpricerRejection(uint256 errorCode);\\r\\n    error LiquidateFreshnessCheck();\\r\\n    error LiquidateCollateralFreshnessCheck();\\r\\n    error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\\r\\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\\r\\n    error LiquidateLiquidatorIsBorrower();\\r\\n    error LiquidateCloseAmountIsZero();\\r\\n    error LiquidateCloseAmountIsUintMax();\\r\\n    error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\\r\\n\\r\\n    error LiquidateSeizeMatrixpricerRejection(uint256 errorCode);\\r\\n    error LiquidateSeizeLiquidatorIsBorrower();\\r\\n\\r\\n    error AcceptAdminPendingAdminCheck();\\r\\n\\r\\n    error SetMatrixpricerOwnerCheck();\\r\\n    error SetTensorpricerOwnerCheck();\\r\\n    error SetPendingAdminOwnerCheck();\\r\\n\\r\\n    error SetReserveFactorAdminCheck();\\r\\n    error SetReserveFactorFreshCheck();\\r\\n    error SetReserveFactorBoundsCheck();\\r\\n\\r\\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\\r\\n\\r\\n    error ReduceReservesAdminCheck();\\r\\n    error ReduceReservesFreshCheck();\\r\\n    error ReduceReservesCashNotAvailable();\\r\\n    error ReduceReservesCashValidation();\\r\\n\\r\\n    error SetInterestRateModelOwnerCheck();\\r\\n    error SetInterestRateModelFreshCheck();\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/ExponentialNoError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n * @title Exponential module for storing fixed-precision decimals\\r\\n * @author Compound\\r\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\r\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\r\\n *         `Exp({mantissa: 5100000000000000000})`.\\r\\n */\\r\\ncontract ExponentialNoError {\\r\\n    uint constant expScale = 1e18;\\r\\n    uint constant doubleScale = 1e36;\\r\\n    uint constant halfExpScale = expScale/2;\\r\\n    uint constant mantissaOne = expScale;\\r\\n\\r\\n    struct Exp {\\r\\n        uint mantissa;\\r\\n    }\\r\\n\\r\\n    struct Double {\\r\\n        uint mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Truncates the given exp to a whole number value.\\r\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\r\\n     */\\r\\n    function truncate(Exp memory exp) pure internal returns (uint) {\\r\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\r\\n        return exp.mantissa / expScale;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\r\\n     */\\r\\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\\r\\n        Exp memory product = mul_(a, scalar);\\r\\n        return truncate(product);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\r\\n     */\\r\\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\\r\\n        Exp memory product = mul_(a, scalar);\\r\\n        return add_(truncate(product), addend);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if first Exp is less than second Exp.\\r\\n     */\\r\\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\r\\n        return left.mantissa < right.mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if left Exp <= right Exp.\\r\\n     */\\r\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\r\\n        return left.mantissa <= right.mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if left Exp > right Exp.\\r\\n     */\\r\\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\r\\n        return left.mantissa > right.mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns true if Exp is exactly zero\\r\\n     */\\r\\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\\r\\n        return value.mantissa == 0;\\r\\n    }\\r\\n\\r\\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\\r\\n        require(n < 2**224, errorMessage);\\r\\n        return uint224(n);\\r\\n    }\\r\\n\\r\\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\\r\\n        require(n < 2**32, errorMessage);\\r\\n        return uint32(n);\\r\\n    }\\r\\n\\r\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\r\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\\r\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function add_(uint a, uint b) pure internal returns (uint) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\r\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\\r\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\r\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\r\\n    }\\r\\n\\r\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\r\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\r\\n        return mul_(a, b.mantissa) / expScale;\\r\\n    }\\r\\n\\r\\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\\r\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\r\\n    }\\r\\n\\r\\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\\r\\n        return Double({mantissa: mul_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\\r\\n        return mul_(a, b.mantissa) / doubleScale;\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\r\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\r\\n        return Exp({mantissa: div_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\r\\n        return div_(mul_(a, expScale), b.mantissa);\\r\\n    }\\r\\n\\r\\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\\r\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\\r\\n        return Double({mantissa: div_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function div_(uint a, Double memory b) pure internal returns (uint) {\\r\\n        return div_(mul_(a, doubleScale), b.mantissa);\\r\\n    }\\r\\n\\r\\n    function div_(uint a, uint b) pure internal returns (uint) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\\r\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/InterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n  * @title Vortex's InterestRateModel Interface\\r\\n  * @author Vortex\\r\\n  */\\r\\nabstract contract InterestRateModel {\\r\\n    /// @notice contract property\\r\\n    bool public constant isInterestRateModel = true;\\r\\n\\r\\n    /**\\r\\n      * @notice Calculates the current borrow interest rate per block\\r\\n      * @param iur ideal utilisation rate\\r\\n      * @param cRatePerBlock compound rate\\r\\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\r\\n      */\\r\\n    function getBorrowRate(uint iur, uint cRatePerBlock) virtual external view returns (uint);\\r\\n\\r\\n    /**\\r\\n      * @notice Calculates the current supply interest rate per block\\r\\n      * @param iur ideal utilisation rate\\r\\n      * @param cRatePerBlock compound rate\\r\\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\\r\\n      */\\r\\n    function getSupplyRate(uint iur, uint cRatePerBlock) virtual external view returns (uint);\\r\\n}\"\r\n    },\r\n    \"contracts/LevErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"./LevToken.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LevErc20 Contract\\r\\n * @notice LevTokens which wrap an EIP-20 underlying\\r\\n * @author Vortex\\r\\n */\\r\\ncontract LevErc20 is LevToken, LevErc20Interface {\\r\\n\\r\\n    string public prologue;\\r\\n\\r\\n    /**\\r\\n     * @notice set depErc20 \\r\\n     * @param depErc20_ The address of the associated depErc20\\r\\n     */\\r\\n    function setDepErc20(DepErc20Interface depErc20_) public override{\\r\\n        super.setDepErc20(depErc20_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initialize the new money market\\r\\n     * @param underlying_ The address of the underlying asset\\r\\n     * @param borrowUnderlying_ The address of the borrow underlying asset\\r\\n     * @param tensorpricer_ The address of the Tensorpricer\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     */\\r\\n    function initialize(address underlying_,\\r\\n                        address borrowUnderlying_,\\r\\n                        TensorpricerInterface tensorpricer_,\\r\\n                        string memory name_,\\r\\n                        string memory symbol_,\\r\\n                        uint8 decimals_) public override initializer {\\r\\n        // LevToken initialize does the bulk of the work\\r\\n        admin = payable(msg.sender);\\r\\n        super.initialize(underlying_, borrowUnderlying_, tensorpricer_, name_, symbol_, decimals_);\\r\\n\\r\\n        // Set underlying and sanity check it\\r\\n        underlying = underlying_;\\r\\n        EIP20Interface(underlying).totalSupply();\\r\\n\\r\\n        // Set borrow underlying and sanity check it\\r\\n        borrowUnderlying = borrowUnderlying_;\\r\\n        EIP20Interface(borrowUnderlying).totalSupply();\\r\\n\\r\\n        netAssetValue = initialNetAssetValueMantissa;\\r\\n        hisHighNav = initialNetAssetValueMantissa;\\r\\n        targetLevRatio = initialTargetLevRatio;\\r\\n    }\\r\\n\\r\\n    function setPrologue() public {\\r\\n        require(msg.sender == admin, \\\"only admin may set prologue\\\");\\r\\n        prologue = 'leverc20 success';\\r\\n    }\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function getAdmin() override external view returns (address payable) {\\r\\n        return admin;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @notice Sender supplies assets into the market and receives depErc20s in exchange\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function mint(uint mintAmount) override external returns (uint) {\\r\\n        require(mintAmount > 0, \\\"cannot mint <= 0\\\");\\r\\n        mintInternal(mintAmount);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @notice Sender redeems levErc20s in exchange for the underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemTokens The number of levErc20s to redeem into USDC\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function redeem(uint redeemTokens) override external returns (uint) {\\r\\n        redeemInternal(redeemTokens);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\r\\n     * @param token The address of the ERC-20 token to sweep\\r\\n     */\\r\\n    function sweepToken(EIP20NonStandardInterface token) override external {\\r\\n        require(msg.sender == admin, \\\"DepErc20::sweepToken: only admin can sweep tokens\\\");\\r\\n        require(address(token) != underlying, \\\"DepErc20::sweepToken: can not sweep underlying token\\\");\\r\\n        uint256 balance = token.balanceOf(address(this));\\r\\n        token.transfer(admin, balance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get extra borrow demand of this levToken\\r\\n     * @return The borrowDemand denominated in borrowUnderlying\\r\\n     */\\r\\n    function getExtraBorrowDemand() override external view returns (uint256){\\r\\n        return extraBorrowDemand;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get extra borrow supply of this levToken\\r\\n     * @return The borrowSupply denominated in borrowUnderlying\\r\\n     */\\r\\n    function getExtraBorrowSupply() override external view returns (uint256){\\r\\n        return extraBorrowSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice depErc20 user (not the contract itself) calls forceRepay\\r\\n     * @param repayAmountInUSDT The amount of underlying to force repay\\r\\n     * @return uint actual amount liquidated\\r\\n     */\\r\\n    function forceRepay(uint256 repayAmountInUSDT) override virtual external returns (uint) {\\r\\n        require(msg.sender==address(depErc20), \\\"only depToken can call forceRepay\\\");\\r\\n//        console.log(\\\"forcerepay triggered,repayAmountInUSDT=\\\",repayAmountInUSDT);\\r\\n        return forceRepayInternal(repayAmountInUSDT);\\r\\n    }\\r\\n\\r\\n    function updateLedger() override virtual external {\\r\\n        require(msg.sender==address(depErc20), \\\"only depToken can call updateLedger\\\");\\r\\n        return updateLedgerInternal();\\r\\n    }\\r\\n\\r\\n    /*** Safe Token ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of the underlying\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of underlying tokens owned by this contract\\r\\n     */\\r\\n    function getCashPrior() virtual override internal view returns (uint) {\\r\\n        EIP20Interface token = EIP20Interface(underlying);\\r\\n//        console.log(\\\"leverc20 cash prior=\\\", token.balanceOf(address(this)));\\r\\n        return token.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\r\\n     *      This will revert due to insufficient balance or insufficient allowance.\\r\\n     *      This function returns the actual amount received,\\r\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\r\\n     *\\r\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\r\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n     */\\r\\n    function doTransferIn(address from, uint amount) virtual override internal returns (uint) {\\r\\n        // Read from storage once\\r\\n        address underlying_ = underlying;\\r\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\\r\\n        uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\\r\\n        token.transferFrom(from, address(this), amount);\\r\\n\\r\\n        bool success;\\r\\n        assembly {\\r\\n            switch returndatasize()\\r\\n                case 0 {                       // This is a non-standard ERC-20\\r\\n                    success := not(0)          // set success to true\\r\\n                }\\r\\n                case 32 {                      // This is a compliant ERC-20\\r\\n                    returndatacopy(0, 0, 32)\\r\\n                    success := mload(0)        // Set `success = returndata` of override external call\\r\\n                }\\r\\n                default {                      // This is an excessively non-compliant ERC-20, revert.\\r\\n                    revert(0, 0)\\r\\n                }\\r\\n        }\\r\\n        require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\r\\n\\r\\n        // Calculate the amount that was *actually* transferred\\r\\n        uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\\r\\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\r\\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\r\\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\r\\n     *      it is >= amount, this should not revert in normal conditions.\\r\\n     *\\r\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\r\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n     */\\r\\n    function doTransferOut(address payable to, uint amount) virtual override internal {\\r\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\\r\\n        token.transfer(to, amount);\\r\\n\\r\\n        bool success;\\r\\n        assembly {\\r\\n            switch returndatasize()\\r\\n                case 0 {                      // This is a non-standard ERC-20\\r\\n                    success := not(0)          // set success to true\\r\\n                }\\r\\n                case 32 {                     // This is a compliant ERC-20\\r\\n                    returndatacopy(0, 0, 32)\\r\\n                    success := mload(0)        // Set `success = returndata` of override external call\\r\\n                }\\r\\n                default {                     // This is an excessively non-compliant ERC-20, revert.\\r\\n                    revert(0, 0)\\r\\n                }\\r\\n        }\\r\\n        require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/LevToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\nimport \\\"./TensorpricerInterface.sol\\\";\\r\\nimport \\\"./LevTokenInterfaces.sol\\\";\\r\\nimport \\\"./ErrorReporter.sol\\\";\\r\\nimport \\\"./EIP20Interface.sol\\\";\\r\\nimport \\\"./ExponentialNoError.sol\\\";\\r\\nimport \\\"./DepositWithdraw.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LevToken Contract\\r\\n * @notice Abstract base for LevTokens\\r\\n * @author Vortex\\r\\n */\\r\\nabstract contract LevToken is LevTokenInterface, DepositWithdraw, CurveSwap, ExponentialNoError, TokenErrorReporter, Initializable {\\r\\n\\r\\n    /**\\r\\n     * @notice set the depErc20 token\\r\\n     * @param depErc20_ The address of the associated depErc20\\r\\n     */\\r\\n    function setDepErc20(DepErc20Interface depErc20_) public virtual{\\r\\n        require(msg.sender == admin, \\\"only admin may set depErc20\\\");\\r\\n        depErc20 = depErc20_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initialize the money market\\r\\n     * @param tensorpricer_ The address of the Tensorpricer\\r\\n     * @param name_ EIP-20 name of this token\\r\\n     * @param symbol_ EIP-20 symbol of this token\\r\\n     * @param decimals_ EIP-20 decimal precision of this token\\r\\n     */\\r\\n    function initialize(address underlying_,\\r\\n                        address borrowUnderlying_,\\r\\n                        TensorpricerInterface tensorpricer_,\\r\\n                        string memory name_,\\r\\n                        string memory symbol_,\\r\\n                        uint8 decimals_) public virtual onlyInitializing {\\r\\n        require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\r\\n        \\r\\n        // Set the tensorpricer\\r\\n        uint err = _setTensorpricer(tensorpricer_);\\r\\n        require(err == NO_ERROR, \\\"setting tensorpricer failed\\\");\\r\\n\\r\\n        name = name_;\\r\\n        symbol = symbol_;\\r\\n        decimals = decimals_;\\r\\n\\r\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initialize the compound portion\\r\\n     * @param compoundV2cUSDCAddress_ The address of the cUSDC\\r\\n     * @param compoundV2cUSDTAddress_ The address of the cUSDT\\r\\n     * @param USDCAddress_ The address of USDC\\r\\n     * @param USDTAddress_ The address of USDT\\r\\n    */\\r\\n    function setAddressesForCompound(address compoundV2cUSDCAddress_, address compoundV2cUSDTAddress_, address USDCAddress_, address USDTAddress_) public {\\r\\n        require(msg.sender==admin, \\\"only admin can set addresses in general\\\");\\r\\n        setAddresses(compoundV2cUSDCAddress_, compoundV2cUSDTAddress_, USDCAddress_, USDTAddress_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initialize the curve portion\\r\\n     * @param TriPool_ The address of the Tripool\\r\\n     * @param ADDRESSPROVIDER_ The address of the curve provider\\r\\n     * @param USDC_ADDRESS_ The address of USDC\\r\\n     * @param USDT_ADDRESS_ The address of USDT\\r\\n    */\\r\\n    function setAddressesForCurve(address TriPool_, address ADDRESSPROVIDER_, address USDC_ADDRESS_, address USDT_ADDRESS_) public {\\r\\n        require(msg.sender==admin, \\\"only admin can set addresses in general\\\");\\r\\n        setAddressesCurve(TriPool_, ADDRESSPROVIDER_, USDC_ADDRESS_, USDT_ADDRESS_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\r\\n     * @dev Called by both `transfer` and `transferFrom` internally\\r\\n     * @param spender The address of the account performing the transfer\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param tokens The number of tokens to transfer\\r\\n     * @return 0 if the transfer succeeded, else revert\\r\\n     */\\r\\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\\r\\n        /* Fail if transfer not allowed */\\r\\n        uint allowed = tensorpricer.transferAllowed(address(this), src, dst, tokens);\\r\\n        if (allowed != 0) {\\r\\n            revert TransferTensorpricerRejection(allowed);   // change the name\\r\\n        }\\r\\n\\r\\n        /* Do not allow self-transfers */\\r\\n        if (src == dst) {\\r\\n            revert TransferNotAllowed();\\r\\n        }\\r\\n\\r\\n        /* Get the allowance, infinite for the account owner */\\r\\n        uint startingAllowance = 0;\\r\\n        if (spender == src) {\\r\\n            startingAllowance = type(uint).max;\\r\\n        } else {\\r\\n            startingAllowance = transferAllowances[src][spender];\\r\\n            if(startingAllowance < tokens){\\r\\n                revert TransferNotEnoughAllowance();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        /* Do the calculations, checking for {under,over}flow */\\r\\n        uint allowanceNew = startingAllowance - tokens;\\r\\n        uint srLevTokensNew = accountTokens[src] - tokens;\\r\\n        uint dstTokensNew = accountTokens[dst] + tokens;\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        accountTokens[src] = srLevTokensNew;\\r\\n        accountTokens[dst] = dstTokensNew;\\r\\n\\r\\n        /* Eat some of the allowance (if necessary) */\\r\\n        if (startingAllowance != type(uint).max) {\\r\\n            transferAllowances[src][spender] = allowanceNew;\\r\\n        }\\r\\n\\r\\n        /* We emit a Transfer event */\\r\\n        emit Transfer(src, dst, tokens);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\\r\\n        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\\r\\n        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n     * @dev This will overwrite the approval amount for `spender`\\r\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\\r\\n     * @return Whether or not the approval succeeded\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) override external returns (bool) {\\r\\n        address src = msg.sender;\\r\\n        transferAllowances[src][spender] = amount;\\r\\n        emit Approval(src, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the current allowance from `owner` for `spender`\\r\\n     * @param owner The address of the account which owns the tokens to be spent\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\r\\n     */\\r\\n    function allowance(address owner, address spender) override external view returns (uint256) {\\r\\n        return transferAllowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the token balance of the `owner`\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The number of tokens owned by `owner`\\r\\n     */\\r\\n    function balanceOf(address owner) override external view returns (uint256) {\\r\\n        return accountTokens[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the nav of the `owner`\\r\\n     * @dev\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The amount of nav owned by `owner`\\r\\n     */\\r\\n    function getNAV(address owner) override external view returns (uint) {\\r\\n        Exp memory nav = Exp({mantissa: netAssetValue});\\r\\n        return mul_ScalarTruncate(nav, accountTokens[owner]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\r\\n     * @dev This is used by tensorpricer to more efficiently perform liquidity checks.\\r\\n     * @param account Address of the account to snapshot\\r\\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\r\\n     */\\r\\n    function getAccountSnapshot(address account) override external view returns (uint, uint) {\\r\\n        return (\\r\\n            NO_ERROR,\\r\\n            accountTokens[account]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get cash balance of this LevToken in USDC\\r\\n     * @return The quantity of USDC owned by this contract (deposits + amt obtained from sale of USDT)\\r\\n     */\\r\\n    function getCash() override external view returns (uint) {\\r\\n        return getCashPrior();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get cash balance deposited at compound\\r\\n     * @return The quantity of underlying asset owned by this contract\\r\\n     */\\r\\n    function getCompoundBalance() override external view returns (uint) {\\r\\n        return getCmpBalanceInternal();\\r\\n    }\\r\\n\\r\\n    function getCmpBalanceInternal() internal view returns (uint) {\\r\\n        Exp memory exchangeRate = Exp({mantissa: getCmpUSDCExchRate()});\\r\\n        return mul_ScalarTruncate(exchangeRate, getCUSDCNumber());\\r\\n    }\\r\\n\\r\\n    function getLevReserve() override external view returns (uint) {\\r\\n        return levReserve;\\r\\n    }\\r\\n\\r\\n    function getHisHighNav() override external view returns (uint) {\\r\\n        return hisHighNav;\\r\\n    }\\r\\n\\r\\n    // rebalance specific:\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the net asset value of the levToken\\r\\n     * @dev\\r\\n     * @return calculated net asset value scaled by 1e18\\r\\n     */\\r\\n    function updateNetAssetValue(uint latestBorrowBalanceUSDC, uint offset) internal {//nonReentrant {\\r\\n        netAssetValue = calcNetAssetValue(latestBorrowBalanceUSDC, offset);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the net asset value of the levToken\\r\\n     * @dev\\r\\n     * @return calculated net asset value scaled by 1e18\\r\\n     */\\r\\n    function calcNetAssetValue(uint latestBorrowBalanceUSDC, uint offset) internal view returns (uint){//nonReentrant {\\r\\n        uint _totalSupply = totalSupply;\\r\\n        if (_totalSupply == 0) {\\r\\n            /*\\r\\n             * If there are no tokens minted:\\r\\n             *  NAV = initialNAV\\r\\n             */\\r\\n            return initialNetAssetValueMantissa;\\r\\n        } else {\\r\\n            /*\\r\\n             * Otherwise:\\r\\n             *  NAV = (USDC_Balance - borrowed_USDT_Balance * fx_USDTUSDC) / totalSupply\\r\\n             */\\r\\n            uint balanceUSDCExReserves = getCashExReserves() + getCmpBalanceInternal();\\r\\n            if(balanceUSDCExReserves > latestBorrowBalanceUSDC + offset){\\r\\n                return (balanceUSDCExReserves - latestBorrowBalanceUSDC - offset) * expScale / _totalSupply;\\r\\n            }else{\\r\\n                return 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateStats(bool recalc, uint tmpTotalAssetValue, uint tmpLevRatio, uint redeemTokensIn) internal {\\r\\n        if(recalc){\\r\\n            uint availCash = getCashExReserves() + getCmpBalanceInternal();\\r\\n            if(redeemTokensIn > 0){\\r\\n                uint currTotalAssetValue;\\r\\n                uint amtToSubtract;\\r\\n                if(availCash > borrowBalanceUSDC){\\r\\n                    currTotalAssetValue = availCash - borrowBalanceUSDC;\\r\\n                    uint currNav = currTotalAssetValue * expScale / totalSupply;\\r\\n                    redeemAmountInUSDC = currNav * redeemTokensIn / expScale;\\r\\n                    //console.log(\\\"calc redeemAmountInUSDC=\\\",redeemAmountInUSDC);\\r\\n                    amtToSubtract = borrowBalanceUSDC + redeemAmountInUSDC;\\r\\n                }else{\\r\\n                    currTotalAssetValue = 0;\\r\\n                    amtToSubtract = borrowBalanceUSDC;\\r\\n                }\\r\\n                if(availCash > amtToSubtract){\\r\\n                    totalAssetValue = availCash - amtToSubtract;\\r\\n                    levRatio = borrowBalanceUSDC*expScale / totalAssetValue;\\r\\n                }else{\\r\\n                    totalAssetValue = 0;\\r\\n                    levRatio = 0;\\r\\n                }\\r\\n            }else{\\r\\n                uint amtToSubtract = borrowBalanceUSDC;\\r\\n                if(availCash > amtToSubtract){\\r\\n                    totalAssetValue = availCash - amtToSubtract;\\r\\n                    levRatio = borrowBalanceUSDC*expScale / totalAssetValue;\\r\\n                }else{\\r\\n                    totalAssetValue = 0;\\r\\n                    levRatio = 0;\\r\\n                }\\r\\n            }\\r\\n        }else{\\r\\n            if(redeemTokensIn > 0){\\r\\n                uint availCash = getCashExReserves() + getCmpBalanceInternal();\\r\\n                //uint currNav = tmpTotalAssetValue * expScale / totalSupply; // wrong\\r\\n                uint currNav = tmpTotalAssetValue * expScale / (totalSupply - redeemTokensIn);\\r\\n                //console.log(\\\"tmpTotalAssetValue=\\\",tmpTotalAssetValue);\\r\\n                redeemAmountInUSDC = currNav * redeemTokensIn / expScale;\\r\\n                //console.log(\\\"non calc redeemAmountInUSDC=\\\",redeemAmountInUSDC);\\r\\n                //console.log(\\\"currNav=\\\",currNav);\\r\\n                uint amtToSubtract = borrowBalanceUSDC + redeemAmountInUSDC;\\r\\n                if(availCash > amtToSubtract){\\r\\n                    totalAssetValue = availCash - amtToSubtract;\\r\\n                    levRatio = borrowBalanceUSDC*expScale / totalAssetValue;\\r\\n                }else{\\r\\n                    totalAssetValue = 0;\\r\\n                    levRatio = 0;\\r\\n                }\\r\\n            }else{  \\r\\n                totalAssetValue = tmpTotalAssetValue;\\r\\n                levRatio = tmpLevRatio; \\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function refreshTargetLevRatio(uint fx_USDTUSDC_Mantissa) public pure returns (uint, uint, uint) {\\r\\n        // targetLevRatio, releverageTrigger, deleverageTrigger\\r\\n        if(fx_USDTUSDC_Mantissa < 6e17 || fx_USDTUSDC_Mantissa > 14e17){\\r\\n            return (1e18, 0, 2e18);\\r\\n        }else if(fx_USDTUSDC_Mantissa < 9e17 || fx_USDTUSDC_Mantissa > 11e17){\\r\\n            return (3e18, 2e18, 4e18);\\r\\n        }else{\\r\\n            return (5e18, 4e18, 6e18);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateExtraBorrow(Exp memory fx_USDTUSDC, uint tmpTotalAssetValue, uint targetLevRatio) internal {\\r\\n        uint targetBorrowUSDT = div_(targetLevRatio*tmpTotalAssetValue/expScale, fx_USDTUSDC);\\r\\n//        console.log(\\\"tmpTotalAssetValue,targetLevRatio=%d,%d\\\",tmpTotalAssetValue,targetLevRatio);\\r\\n//        console.log(\\\"targetBorrowUSDT,borrowBalanceUSDT=%d,%d\\\",targetBorrowUSDT,borrowBalanceUSDT);\\r\\n        if(targetBorrowUSDT > borrowBalanceUSDT){\\r\\n            extraBorrowDemand = targetBorrowUSDT - borrowBalanceUSDT;\\r\\n            extraBorrowSupply = 0;\\r\\n        }else{\\r\\n            extraBorrowDemand = 0;\\r\\n            extraBorrowSupply = borrowBalanceUSDT - targetBorrowUSDT;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateBorrowBalances(uint fxToUse, uint newBorrowBalanceUSDT) internal {\\r\\n        borrowBalanceUSDT = newBorrowBalanceUSDT;\\r\\n        borrowBalanceUSDC = newBorrowBalanceUSDT * fxToUse / expScale;\\r\\n    }\\r\\n\\r\\n    function releverage(uint newBorrowDemand) internal {\\r\\n        // depToken goes to curve to sell its own USDT to USDC pushing USDC to leverager directly. simple\\r\\n        uint transFx = depErc20.borrow(newBorrowDemand);\\r\\n        updateBorrowBalances(transFx, depErc20.getTotalBorrows());  // only 1 borrower, no need to parse in address\\r\\n    }\\r\\n\\r\\n    function deleverage(Exp memory fx_USDTUSDC, uint newBorrowSupply, bool isRedeemAll) internal returns (bool) {\\r\\n        uint amtUSDC = mul_(newBorrowSupply, fx_USDTUSDC);\\r\\n        if(isRedeemAll){\\r\\n            amtUSDC = amtUSDC * 105 / 100;  // add 5% buffer\\r\\n            withdrawUSDCfromCmp(getCmpBalanceInternal());  // taking out all we have\\r\\n        }else{\\r\\n            uint cashOnBook = getCashExReserves();\\r\\n            if(amtUSDC > cashOnBook){   // we still have cash in wallet, may not need to go to compound\\r\\n                uint amtUSDCmissing = amtUSDC - cashOnBook;\\r\\n                // need to go to compound to get the USDC\\r\\n                uint compoundBalance = getCmpBalanceInternal();\\r\\n                if(compoundBalance > (amtUSDCmissing + extraUSDC)){\\r\\n                    withdrawUSDCfromCmp(amtUSDCmissing + extraUSDC);\\r\\n                }else{\\r\\n                    withdrawUSDCfromCmp(compoundBalance);  // taking out all we have, but may not be enough still!\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        // levToken goes to curve to sell its USDC to USDT pushing USDT to depositor directly\\r\\n        uint latestCashOnBook = getCashExReserves();\\r\\n        uint finalRepayAmount;\\r\\n        if(latestCashOnBook >= amtUSDC){ // normal case\\r\\n            finalRepayAmount = changeUSDC2USDT(amtUSDC, 0, address(depErc20));\\r\\n//            console.log(\\\"changed %d usdc into %d usdt\\\",amtUSDC,finalRepayAmount);\\r\\n            uint transFx = amtUSDC * expScale / finalRepayAmount;\\r\\n            // we accrueInterest & update the ledgers in depErc20 after the transfer!\\r\\n            depErc20.repayBorrow(finalRepayAmount, false);\\r\\n            updateBorrowBalances(transFx, depErc20.getTotalBorrows());  // only 1 borrower, no need to parse in address\\r\\n        }else{\\r\\n            finalRepayAmount = changeUSDC2USDT(latestCashOnBook, 0, address(depErc20)); // best efforts\\r\\n//            console.log(\\\"(insufficient) changed %d usdc into %d usdt\\\",latestCashOnBook,finalRepayAmount);\\r\\n            uint transFx = latestCashOnBook * expScale / finalRepayAmount;\\r\\n            if(isRedeemAll){\\r\\n//                console.log(\\\"liquidation during deleverage, nav -> 0\\\");\\r\\n                uint depTotalBorrows = depErc20.getTotalBorrows();\\r\\n                if(depTotalBorrows > finalRepayAmount){ // insufficient, record how much owed\\r\\n                    updateBorrowBalances(transFx, depTotalBorrows - finalRepayAmount);\\r\\n                }else{\\r\\n                    updateBorrowBalances(transFx, 0); // repaid too much, deptoken will push back extra, and zero its totalBorrows\\r\\n                }\\r\\n                depErc20.repayBorrow(finalRepayAmount, true);\\r\\n                return true;    // liquidation triggered\\r\\n            }else{\\r\\n                // we accrueInterest & update the ledgers in depErc20 after the transfer!\\r\\n                depErc20.repayBorrow(finalRepayAmount, false);\\r\\n                updateBorrowBalances(transFx, depErc20.getTotalBorrows());  // only 1 borrower, no need to parse in address\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function deleverageAll() internal returns (bool) {\\r\\n//        console.log(\\\"deleverageAll triggered!\\\");\\r\\n        uint cashOnBook = getCashExReserves();\\r\\n        // need to go to compound to get the USDC\\r\\n        uint compoundBalance = getCmpBalanceInternal();\\r\\n//        console.log(\\\"cashOnBook,compoundBalance=%d,%d\\\", cashOnBook, compoundBalance);\\r\\n        if(compoundBalance > 0) {\\r\\n            withdrawUSDCfromCmp(compoundBalance);  // taking out all we have\\r\\n        }\\r\\n        cashOnBook = getCashExReserves();   // query again, since withdrawal from cmp costs gas. this now includes true amt withdrawn from cmp\\r\\n        // levToken goes to curve to sell all its USDC to USDT pushing USDT to depositor directly\\r\\n        if(cashOnBook > 0){\\r\\n            uint finalRepayAmount = changeUSDC2USDT(cashOnBook, 0, address(depErc20));\\r\\n//            console.log(\\\"changed %d usdc into %d usdt\\\",cashOnBook,finalRepayAmount);\\r\\n            uint transFx = cashOnBook * expScale / finalRepayAmount;\\r\\n            // we accrueInterest & update the ledgers in depErc20 after the transfer!\\r\\n            uint origBorrowBalanceUSDT = depErc20.getTotalBorrowsAfterAccrueInterest();    // hasnt taken into account the repayment above yet\\r\\n            extraBorrowDemand = 0;\\r\\n            extraBorrowSupply = 0;\\r\\n//            console.log(\\\"finalRepayAmount,origBorrowBalanceUSDT=%d,%d\\\", finalRepayAmount, origBorrowBalanceUSDT);\\r\\n            if(origBorrowBalanceUSDT > finalRepayAmount){\\r\\n                updateBorrowBalances(transFx, origBorrowBalanceUSDT - finalRepayAmount);  // record in borrowBalanceUSDT the bad debt\\r\\n                depErc20.repayBorrow(finalRepayAmount, true);\\r\\n                updateStats(false, 0, 0, 0);\\r\\n                tensorpricer._setMintPausedLev(address(this), true);\\r\\n                tensorpricer._setRedeemPausedLev(address(this), true);\\r\\n            }else{  // enough to pay\\r\\n                updateBorrowBalances(transFx, 0);\\r\\n                depErc20.repayBorrow(finalRepayAmount, false);\\r\\n                updateStats(true, 0, 0, 0);\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function checkRebalanceExt() external view returns (checkRebalanceRes memory) {\\r\\n        return checkRebalance(2, 0);\\r\\n    }\\r\\n\\r\\n    function checkRebalance(uint callingSrc, uint tmpRedeemAmountInUSDC) internal view returns (checkRebalanceRes memory) {\\r\\n        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');\\r\\n        (uint targetLevRatio, uint releverageTrigger, uint deleverageTrigger) = refreshTargetLevRatio(fx_USDTUSDC_Mantissa);\\r\\n        Exp memory fx_USDTUSDC = Exp({mantissa: fx_USDTUSDC_Mantissa});\\r\\n        \\r\\n        //uint fxmantissa = fx_USDTUSDC.mantissa;\\r\\n        //console.log(\\\"fx,\\\",fxmantissa);\\r\\n        //console.log(\\\"checkrebalance,%d,%d,%d\\\",targetLevRatio,releverageTrigger,deleverageTrigger);\\r\\n        if(callingSrc==0){   // mint. new USDC already in\\r\\n            uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);\\r\\n            uint tmpBalanceUSDC = getCashExReserves() + getCmpBalanceInternal();\\r\\n            if(tmpBalanceUSDC > tmpBorrowBalanceUSDC){\\r\\n                uint tmpTotalAssetValue = tmpBalanceUSDC - tmpBorrowBalanceUSDC;\\r\\n                uint tmpLevRatio = tmpBorrowBalanceUSDC*expScale / tmpTotalAssetValue;\\r\\n                \\r\\n                if(tmpLevRatio < releverageTrigger){    // need to leverage up\\r\\n                    return checkRebalanceRes({res:1, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});\\r\\n                }else if(tmpLevRatio > deleverageTrigger){\\r\\n                    return checkRebalanceRes({res:2, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});\\r\\n                }else{  //no changes\\r\\n                    return checkRebalanceRes({res:0, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});\\r\\n                }\\r\\n            }else{\\r\\n                return checkRebalanceRes({res:3, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:0, tmpLevRatio:0});\\r\\n            }\\r\\n        }else if (callingSrc==1){  // redeem. USDC NOT transferred out yet\\r\\n            if(totalSupply > 0){\\r\\n                //console.log(\\\"getCashExReserves=\\\",getCashExReserves());\\r\\n                //console.log(\\\"getCmpBalanceInternal=\\\",getCmpBalanceInternal());\\r\\n                //console.log(\\\"tmpRedeemAmountInUSDC=\\\",tmpRedeemAmountInUSDC);\\r\\n                uint tmpBalanceUSDC = getCashExReserves() + getCmpBalanceInternal() - tmpRedeemAmountInUSDC;\\r\\n                //console.log(\\\"tmpBalanceUSDC=\\\",tmpBalanceUSDC);\\r\\n\\r\\n                //console.log(\\\"borrowBalanceUSDT=\\\",borrowBalanceUSDT);\\r\\n                //console.log(\\\"fx_USDTUSDC=\\\",fx_USDTUSDC_Mantissa);\\r\\n                uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);\\r\\n                //console.log(\\\"tmpBorrowBalanceUSDC=\\\",tmpBorrowBalanceUSDC);\\r\\n                \\r\\n                if(tmpBalanceUSDC > tmpBorrowBalanceUSDC){\\r\\n                    uint tmpTotalAssetValue = tmpBalanceUSDC - tmpBorrowBalanceUSDC;\\r\\n                    uint tmpLevRatio = tmpBorrowBalanceUSDC*expScale / tmpTotalAssetValue;\\r\\n//                    console.log(\\\"tmpBalanceUSDC,tmpBorrowBalanceUSDC=%d,%d\\\",tmpBalanceUSDC,tmpBorrowBalanceUSDC);\\r\\n                    if(tmpLevRatio > deleverageTrigger){ // need to work out a new nav\\r\\n                        return checkRebalanceRes({res:2, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});\\r\\n                    }else if(tmpLevRatio < releverageTrigger){\\r\\n                        return checkRebalanceRes({res:1, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});\\r\\n                    }else{  // no changes, only redeemAmount*nav USDC will be transferred out\\r\\n                        return checkRebalanceRes({res:0, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});\\r\\n                    }\\r\\n                }else{\\r\\n                    return checkRebalanceRes({res:3, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:0, tmpLevRatio:0});\\r\\n                }\\r\\n            }else{\\r\\n                return checkRebalanceRes({res:0, targetLevRatio:0, tmpBorrowBalanceUSDC:0, tmpTotalAssetValue:0, tmpLevRatio:0});\\r\\n            }\\r\\n        }else{  // regular check due to fx\\r\\n            if(totalSupply > 0){\\r\\n                uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);\\r\\n                uint tmpBalanceUSDC = getCashExReserves() + getCmpBalanceInternal();\\r\\n                if(tmpBalanceUSDC > tmpBorrowBalanceUSDC){\\r\\n                    uint tmpTotalAssetValue = tmpBalanceUSDC - tmpBorrowBalanceUSDC;\\r\\n                    uint tmpLevRatio = tmpBorrowBalanceUSDC*expScale / tmpTotalAssetValue;\\r\\n\\r\\n                    if(tmpLevRatio < releverageTrigger){    // need to leverage up\\r\\n                        return checkRebalanceRes({res:1, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});\\r\\n                    }else if(tmpLevRatio > deleverageTrigger){ // need to work out a new nav\\r\\n                        return checkRebalanceRes({res:2, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});\\r\\n                    }else{\\r\\n                        return checkRebalanceRes({res:0, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});\\r\\n                    }\\r\\n                }else{\\r\\n                    return checkRebalanceRes({res:3, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:0, tmpLevRatio:0});\\r\\n                }\\r\\n            }else{\\r\\n                return checkRebalanceRes({res:0, targetLevRatio:0, tmpBorrowBalanceUSDC:0, tmpTotalAssetValue:0, tmpLevRatio:0});\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function doRebalanceExt() public {//nonReentrant {\\r\\n        checkRebalanceRes memory myRes = checkRebalance(2, 0);\\r\\n        doRebalance(2, myRes, 0);\\r\\n    }\\r\\n\\r\\n    function doRebalance(uint callingSrc, checkRebalanceRes memory myRes, uint redeemTokensIn) internal {//nonReentrant {\\r\\n        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');\\r\\n        Exp memory fx_USDTUSDC = Exp({mantissa: fx_USDTUSDC_Mantissa});\\r\\n        targetLevRatio = myRes.targetLevRatio;  // if we go to do reBalance, update it, else needs to pay gas\\r\\n        if(myRes.res == 3){ // need to clear all positions\\r\\n            if(deleverageAll()){\\r\\n                netAssetValue = 0;\\r\\n            }else{\\r\\n                updateNetAssetValue(borrowBalanceUSDC, 0);\\r\\n            }\\r\\n        }else{\\r\\n            if(callingSrc==0){   // mint. new USDC already in\\r\\n                if(myRes.res==1){    // need to leverage up\\r\\n                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);\\r\\n                    // releverage\\r\\n                    if(extraBorrowDemand > 0) {\\r\\n                        releverage(extraBorrowDemand);\\r\\n                    }else{\\r\\n                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;\\r\\n                    }\\r\\n                    updateStats(true, 0, 0, 0);\\r\\n                }else if(myRes.res==2){\\r\\n                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);\\r\\n                    // deleverage\\r\\n                    if(extraBorrowSupply > 0){\\r\\n                        deleverage(fx_USDTUSDC, extraBorrowSupply, false);\\r\\n                    }else{\\r\\n                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;\\r\\n                    }\\r\\n                    updateStats(true, 0, 0, 0);\\r\\n                }else if(myRes.res==0){  //no changes. do NOT expect deleverage here\\r\\n                    borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;\\r\\n                    updateStats(false, myRes.tmpTotalAssetValue, myRes.tmpLevRatio, 0);\\r\\n                    extraBorrowDemand = 0;\\r\\n                    extraBorrowSupply = 0;\\r\\n                }\\r\\n            }else if (callingSrc==1){  // redeem. USDC NOT transferred out yet\\r\\n                if(myRes.res==2){ // need to work out a new nav\\r\\n                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);\\r\\n                    // deleverage\\r\\n                    if(extraBorrowSupply > 0){\\r\\n                        deleverage(fx_USDTUSDC, extraBorrowSupply, false);\\r\\n                    }else{\\r\\n                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;\\r\\n                    }\\r\\n                    updateStats(true, 0, 0, redeemTokensIn);\\r\\n                }else if(myRes.res==1){\\r\\n                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);\\r\\n                    // releverage\\r\\n                    if(extraBorrowDemand > 0) {\\r\\n                        releverage(extraBorrowDemand);\\r\\n                    }else{\\r\\n                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;\\r\\n                    }\\r\\n                    updateStats(true, 0, 0, redeemTokensIn);\\r\\n                }else if(myRes.res==0){  // no changes, only redeemAmount*nav USDC will be transferred out\\r\\n                    borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;\\r\\n                    updateStats(false, myRes.tmpTotalAssetValue, myRes.tmpLevRatio, redeemTokensIn);\\r\\n                    extraBorrowDemand = 0;\\r\\n                    extraBorrowSupply = 0;\\r\\n                }\\r\\n            }else{  // this is for Keeper. dont come to this function at all if res==0\\r\\n                if(myRes.res==1){    // need to leverage up\\r\\n                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);\\r\\n                    // releverage\\r\\n                    if(extraBorrowDemand > 0) {\\r\\n                        releverage(extraBorrowDemand);\\r\\n                    }else{\\r\\n                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;\\r\\n                    }\\r\\n                    // only need to do supplyUSDC for callingSrc 2, but not callingSrc 0, \\r\\n                    // because callingSrc 0 calls it separately\\r\\n                    uint currUSDCBalance = getCashExReserves();\\r\\n                    if(checkCompound(currUSDCBalance)){\\r\\n                        supplyUSDC(currUSDCBalance - thresholdUSDC);\\r\\n                    }\\r\\n                    updateStats(true, 0, 0, 0);\\r\\n                    updateNetAssetValue(borrowBalanceUSDC, 0);  // again only for callingSrc!=0, coz callingSrc 0 calls it after totalSupply update\\r\\n                }else if(myRes.res==2){ // need to work out a new nav\\r\\n                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);\\r\\n                    // deleverage\\r\\n                    if(extraBorrowSupply > 0){\\r\\n                        deleverage(fx_USDTUSDC, extraBorrowSupply, false);\\r\\n                    }else{\\r\\n                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;\\r\\n                    }\\r\\n                    updateStats(true, 0, 0, 0);\\r\\n                    updateNetAssetValue(borrowBalanceUSDC, 0);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function redeemAllRebalance() internal returns (uint){\\r\\n        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');\\r\\n        Exp memory fx_USDTUSDC = Exp({mantissa: fx_USDTUSDC_Mantissa});\\r\\n        extraBorrowDemand = 0;\\r\\n        extraBorrowSupply = borrowBalanceUSDT;\\r\\n        bool isLiquidate = deleverage(fx_USDTUSDC, extraBorrowSupply, true);    // this takes out everything we have in cmp\\r\\n        if(isLiquidate){\\r\\n            updateStats(false, 0, 0, 0);\\r\\n            netAssetValue = 0;\\r\\n            tensorpricer._setMintPausedLev(address(this), true);\\r\\n            tensorpricer._setRedeemPausedLev(address(this), true);\\r\\n//            console.log(\\\"redeemAllRebalance liquidate triggered\\\");\\r\\n            return 0;\\r\\n        }else{\\r\\n            uint currUSDCBalance = getCashExReserves(); // all available cash on the book now\\r\\n            uint redeemFeeBeforeLevRatio = (redeemFeePC * currUSDCBalance) / expScale;\\r\\n            uint redeemFee = (targetLevRatio * redeemFeeBeforeLevRatio) / expScale;\\r\\n            \\r\\n//            console.log(\\\"redeemFee =\\\",redeemFee);\\r\\n            if(currUSDCBalance <= redeemFee){\\r\\n                redeemFee = currUSDCBalance;\\r\\n//                console.log(\\\"currUSDCBalance not enough. redeemFee reduced to =\\\",redeemFee);\\r\\n                currUSDCBalance = 0;\\r\\n            }else{\\r\\n                currUSDCBalance = currUSDCBalance - redeemFee;\\r\\n            }\\r\\n\\r\\n            levReserve = levReserve + redeemFee;\\r\\n            updateStats(false, 0, 0, 0);\\r\\n            netAssetValue = initialNetAssetValueMantissa;\\r\\n\\r\\n            return currUSDCBalance;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice check if sufficient USDC to push to compound\\r\\n     * @dev\\r\\n     * @return if true, then transfer\\r\\n     */\\r\\n    function checkCompound(uint currUSDCBalance) internal pure returns (bool) {\\r\\n        if(currUSDCBalance > minTransferAmtUSDC+thresholdUSDC){\\r\\n            return true;\\r\\n        }else{\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function checkLeveragibility(Exp memory fx_USDTUSDC, uint mintAmount) internal view returns (bool) {\\r\\n        uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);\\r\\n        uint availCash = getCashExReserves() + getCmpBalanceInternal();\\r\\n        uint tmpLevRatio = 0;\\r\\n//        console.log(\\\"tmpBorrowBalanceUSDC\\\",tmpBorrowBalanceUSDC);\\r\\n//        console.log(\\\"availCash\\\",availCash);\\r\\n        if(availCash > tmpBorrowBalanceUSDC){   // minting may still be possible, depending on unborrowedCashAtDep > loanNeeded\\r\\n            uint tmpTotalAssetValue = availCash - tmpBorrowBalanceUSDC;\\r\\n            tmpLevRatio = tmpBorrowBalanceUSDC*expScale / tmpTotalAssetValue;\\r\\n//            console.log(\\\"tmpLevRatio\\\",tmpLevRatio);\\r\\n        }else{  // both availCash & tmpBorrowBalanceUSDC are zero\\r\\n            (uint initLevRatio,,) = refreshTargetLevRatio(fx_USDTUSDC.mantissa);\\r\\n            tmpLevRatio = initLevRatio;\\r\\n        }\\r\\n        uint loanNeeded = tmpLevRatio * div_(mintAmount, fx_USDTUSDC) / expScale;\\r\\n        uint unborrowedCashAtDep = depErc20.getUnborrowedUSDTBalance();\\r\\n        \\r\\n//        console.log(\\\"loanNeeded\\\",loanNeeded);\\r\\n//        console.log(\\\"unborrowedCashAtDep\\\",unborrowedCashAtDep);\\r\\n        return unborrowedCashAtDep > loanNeeded;\\r\\n    }\\r\\n\\r\\n    function payback(address minter, uint _totalAssetValue) internal {\\r\\n        if(_totalAssetValue > 0){\\r\\n            // this is another undesirable scenario. dont issue new tokens, return as much to minter as possible. stop further mint/redeem\\r\\n            uint compoundBalance = getCmpBalanceInternal();\\r\\n            if(compoundBalance > 0){\\r\\n                withdrawUSDCfromCmp(compoundBalance);  // taking out all we have\\r\\n            }\\r\\n            doTransferOut(payable(minter), _totalAssetValue);\\r\\n//            console.log(\\\"return as much as possible,\\\",_totalAssetValue);\\r\\n            emit Transfer(minter, address(this), 0);\\r\\n        }\\r\\n        updateStats(false, 0, 0, 0);\\r\\n        extraBorrowDemand = 0;\\r\\n        extraBorrowSupply = 0;\\r\\n        netAssetValue = 0;\\r\\n        tensorpricer._setMintPausedLev(address(this), true);\\r\\n        tensorpricer._setRedeemPausedLev(address(this), true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice User supplies USDC into the market and receives levErc20s in exchange\\r\\n     * @param mintAmount The amount of USDC to supply\\r\\n     */\\r\\n    function mintInternal(uint mintAmount) internal nonReentrant {\\r\\n        address minter = msg.sender;   //The address of the account which is supplying USDC\\r\\n        /* Fail if mint not allowed */\\r\\n        uint allowed = tensorpricer.mintAllowed(address(this), minter);\\r\\n        if (allowed != 0) {\\r\\n            revert MintTensorpricerRejection(allowed);\\r\\n        }\\r\\n\\r\\n        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');\\r\\n        Exp memory fx_USDTUSDC = Exp({mantissa: fx_USDTUSDC_Mantissa});\\r\\n//        console.log(\\\"mint fx=\\\",fx_USDTUSDC_Mantissa);\\r\\n\\r\\n        //require(checkLeveragibility(fx_USDTUSDC, mintAmount), \\\"not enough deposit to create\\\");\\r\\n        if(!checkLeveragibility(fx_USDTUSDC, mintAmount)){\\r\\n//            console.log(\\\"not enough deposit to create\\\");\\r\\n            return;\\r\\n        }\\r\\n        // require(checkLeveragibility(fx_USDTUSDC, mintAmount), \\\"not enough deposit to create\\\");\\r\\n        // start executing transfers according to the completed calculations\\r\\n\\r\\n        /*\\r\\n         *  We call `doTransferIn` for the minter and the mintAmount.\\r\\n         *  Note: The levErc20 can only handle USDC!\\r\\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if side-effects occurred. \\r\\n         *  The function returns the amount actually transferred, in case of a fee. \\r\\n         *  On success, the levErc20 holds an additional `actualMintAmount` of cash.\\r\\n         *  getCash() will reflect this transfer\\r\\n         */\\r\\n        uint actualMintAmount = doTransferIn(minter, mintAmount);\\r\\n\\r\\n        uint mintTokens;\\r\\n        uint navAfterTradeMantissa;\\r\\n        // update a tmp new nav\\r\\n        Exp memory tmpNav;\\r\\n        uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);\\r\\n        uint tmpNavMantissa = calcNetAssetValue(tmpBorrowBalanceUSDC, actualMintAmount);\\r\\n        bool skipRebalance = false;\\r\\n        if(tmpNavMantissa == 0){\\r\\n            if(deleverageAll()){\\r\\n                return;\\r\\n            }\\r\\n            skipRebalance = true;\\r\\n        }\\r\\n        \\r\\n        tmpNav = Exp({mantissa: takePerfFee(tmpNavMantissa)});\\r\\n\\r\\n        /*\\r\\n        *  calculate the number of levErc20s to be minted:\\r\\n        *  mintTokens = actualMintAmount / netassetvalue\\r\\n        */\\r\\n        \\r\\n        checkRebalanceRes memory myRes;\\r\\n        if(!skipRebalance){\\r\\n            myRes = checkRebalance(0, 0);\\r\\n//            console.log(\\\"checkRebalance res:\\\",myRes.res);\\r\\n//            console.log(\\\"checkRebalance targetLevRatio:\\\",myRes.targetLevRatio);\\r\\n            doRebalance(0, myRes, 0);    // rebalance will have been done if needed\\r\\n        }\\r\\n        \\r\\n        if(!skipRebalance && myRes.res==0){   // no rebalances\\r\\n            mintTokens = div_(actualMintAmount, tmpNav);\\r\\n        }else{  // use rebalance fx\\r\\n            // totalassetvalue already updated by now\\r\\n            uint _totalSupply = totalSupply;\\r\\n            if(_totalSupply == 0){\\r\\n                navAfterTradeMantissa = initialNetAssetValueMantissa;\\r\\n                mintTokens = div_(actualMintAmount, Exp({mantissa: navAfterTradeMantissa}));\\r\\n            }else{\\r\\n                uint _totalAssetValue = totalAssetValue;\\r\\n                if(_totalAssetValue > actualMintAmount){\\r\\n                    navAfterTradeMantissa = (_totalAssetValue - actualMintAmount) * expScale / _totalSupply;\\r\\n                    mintTokens = div_(actualMintAmount, Exp({mantissa: navAfterTradeMantissa}));\\r\\n                }else{\\r\\n                    payback(minter, _totalAssetValue);\\r\\n                    return;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint currUSDCBalance = getCashExReserves();\\r\\n        if(checkCompound(currUSDCBalance)){\\r\\n            supplyUSDC(currUSDCBalance - thresholdUSDC);\\r\\n        }\\r\\n        \\r\\n        /*\\r\\n         * We calculate the new total supply of levErc20s and minter token balance, checking for overflow:\\r\\n         *  totalSupplyNew = totalSupply + mintTokens\\r\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\r\\n         * And write them into storage\\r\\n         */\\r\\n        totalSupply = totalSupply + mintTokens;\\r\\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\\r\\n        // once totalSupply updated, we update nav\\r\\n        updateNetAssetValue(borrowBalanceUSDC, 0);\\r\\n        /* We emit a Mint event, and a Transfer event */\\r\\n        emit Mint(minter, actualMintAmount, mintTokens, netAssetValue);\\r\\n        emit Transfer(address(this), minter, mintTokens);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems levErc20s in exchange for the underlying asset\\r\\n     * @dev\\r\\n     * @param redeemTokens The number of levErc20s to redeem into underlying\\r\\n     */\\r\\n    function redeemInternal(uint redeemTokensIn) internal nonReentrant {\\r\\n        address payable redeemer = payable(msg.sender);\\r\\n\\r\\n        /* Fail if redeem not allowed */\\r\\n        uint allowed = tensorpricer.redeemAllowed(address(this), redeemer, redeemTokensIn);\\r\\n        if (allowed != 0) {\\r\\n            revert RedeemTensorpricerRejection(allowed);\\r\\n        }\\r\\n\\r\\n        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');\\r\\n        //console.log(\\\"redeem fx=\\\",fx_USDTUSDC_Mantissa);\\r\\n\\r\\n        // work out a tmpNetAssetValue here\\r\\n        uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, Exp({mantissa: fx_USDTUSDC_Mantissa}));\\r\\n        //console.log(\\\"tmpBorrowBalanceUSDC=%d\\\",tmpBorrowBalanceUSDC);\\r\\n        uint tmpNetAssetValue = calcNetAssetValue(tmpBorrowBalanceUSDC, 0);\\r\\n        (uint targetLevRatio,,) = refreshTargetLevRatio(fx_USDTUSDC_Mantissa);\\r\\n\\r\\n        /*\\r\\n        *  We calculate the nav and the amount of underlying to be redeemed:\\r\\n        *  redeemTokens = redeemTokensIn\\r\\n        *  redeemAmount = redeemTokensIn x nav\\r\\n        */\\r\\n        \\r\\n        uint updatedTmpNavMantissa = takePerfFee(tmpNetAssetValue);  // take fees first before calculating the latest redeemable nav\\r\\n        uint tmpRedeemAmount = mul_ScalarTruncate(Exp({mantissa: updatedTmpNavMantissa}), redeemTokensIn);\\r\\n\\r\\n        uint trueRedeemAmount;\\r\\n        if(totalSupply == redeemTokensIn){  // redeem all, special logic\\r\\n            trueRedeemAmount = redeemAllRebalance();\\r\\n            totalSupply = 0;\\r\\n        }else{\\r\\n            redeemAmountInUSDC = 0; // let do rebalance update it\\r\\n            if(tmpNetAssetValue > 0){\\r\\n                doRebalance(1, checkRebalance(1, tmpRedeemAmount), redeemTokensIn);    // rebalance will have been done if needed\\r\\n            }else{\\r\\n                if(deleverageAll()){\\r\\n                    emit Redeem(redeemer, 0, redeemTokensIn, netAssetValue);\\r\\n                    return;\\r\\n                }\\r\\n            }\\r\\n        \\r\\n            // then we use the new latest (but not final) nav (updated in doRebalance) to work out how much to pay client\\r\\n            // we dont subtract redeemAmount, nor reduce totalSupply when computing this new latest nav\\r\\n            uint redeemFeeBeforeLevRatio = (redeemFeePC * redeemAmountInUSDC) / expScale;\\r\\n            uint redeemFee = (targetLevRatio * redeemFeeBeforeLevRatio) / expScale;\\r\\n            \\r\\n//            console.log(\\\"redeemFee =\\\",redeemFee);\\r\\n\\r\\n            trueRedeemAmount = redeemAmountInUSDC - redeemFee;\\r\\n            levReserve = levReserve + redeemFee;\\r\\n\\r\\n            uint currUSDCBalance = getCashExReserves();\\r\\n            if (redeemAmountInUSDC > currUSDCBalance) { // need to get some funds from Compound\\r\\n                uint amtNeeded = redeemAmountInUSDC - currUSDCBalance;\\r\\n                uint compoundBalance = getCmpBalanceInternal();\\r\\n                if(compoundBalance > (amtNeeded + extraUSDC)){\\r\\n                    withdrawUSDCfromCmp(amtNeeded + extraUSDC);\\r\\n                }else{\\r\\n                    withdrawUSDCfromCmp(compoundBalance);  // taking out all we have\\r\\n                }\\r\\n            }\\r\\n            totalSupply = totalSupply - redeemTokensIn;\\r\\n            updateNetAssetValue(borrowBalanceUSDC, trueRedeemAmount); // transferOut NOT done yet!\\r\\n        }\\r\\n        /*\\r\\n        * We write the previously calculated values into storage.\\r\\n        *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\\r\\n        */\\r\\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokensIn;\\r\\n        /*\\r\\n        * We invoke doTransferOut for the redeemer and the redeemAmount.\\r\\n        *  On success, the depErc20 has redeemAmount less of cash.\\r\\n        *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n        */\\r\\n        if(trueRedeemAmount > 0){\\r\\n            doTransferOut(redeemer, trueRedeemAmount);\\r\\n            /* We emit a Transfer event, and a Redeem event */\\r\\n            emit Transfer(redeemer, address(this), redeemTokensIn);\\r\\n            emit Redeem(redeemer, trueRedeemAmount, redeemTokensIn, netAssetValue);\\r\\n        }else{\\r\\n            emit Redeem(redeemer, 0, redeemTokensIn, netAssetValue);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice depErc20 user forces levToken to repay. User sells USDC to get USDT\\r\\n     * @param repayAmountInUSDT The amt of USDT needed\\r\\n     * @return net proceeds. it goes directly to the depToken\\r\\n     */\\r\\n    function forceRepayInternal(uint repayAmountInUSDT) internal nonReentrant returns (uint) {\\r\\n        // need to determine how much USDC is needed. do as the oracle says\\r\\n        Exp memory fx_USDTUSDC = Exp({mantissa: tensorpricer.getFx('USDTUSDC')});\\r\\n        uint amtUSDC = mul_(repayAmountInUSDT, fx_USDTUSDC);\\r\\n        amtUSDC = (amtUSDC * 105) / 100;    // we add 5% as buffer\\r\\n        uint availCash = getCashExReserves();\\r\\n        if(amtUSDC > availCash){\\r\\n            uint amtUSDCmissing = amtUSDC - availCash; // we still have cash in wallet\\r\\n            // need to go to compound to get the USDC\\r\\n            uint compoundBalance = getCmpBalanceInternal();\\r\\n            if(compoundBalance > (amtUSDCmissing + extraUSDC)){\\r\\n                withdrawUSDCfromCmp(amtUSDCmissing + extraUSDC);\\r\\n            }else{\\r\\n                withdrawUSDCfromCmp(compoundBalance);  // taking out all we have\\r\\n            }\\r\\n        }\\r\\n        uint netForceRepayAmount = changeUSDC2USDT(amtUSDC, 0, address(depErc20));\\r\\n//        console.log(\\\"changed %d usdc into %d usdt\\\",amtUSDC,netForceRepayAmount);\\r\\n        return netForceRepayAmount;\\r\\n    }\\r\\n\\r\\n    function updateLedgerInternal() internal {\\r\\n        updateBorrowBalances(tensorpricer.getFx('USDTUSDC'), depErc20.getTotalBorrows());   // no need to use transFx even tho traded, becoz no lev mint/redeem\\r\\n        updateStats(true, 0, 0, 0);\\r\\n        updateNetAssetValue(borrowBalanceUSDC, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice push a portion of profit to reserves \\r\\n     */\\r\\n    function takePerfFee(uint navMantissa) internal returns (uint) {\\r\\n        uint perfFee = 0;\\r\\n        if(navMantissa > hisHighNav && totalSupply > 0){\\r\\n//            console.log(\\\"netnav,hishighnav = %d,%d\\\",navMantissa,hisHighNav);\\r\\n            uint gain = (navMantissa-hisHighNav) * totalSupply / expScale;    // gain same unit as totalSupply, 1e6\\r\\n            hisHighNav = navMantissa;\\r\\n            perfFee = gain * perfPC / expScale;\\r\\n            uint tmpTotalAssetValue = navMantissa * totalSupply / expScale;\\r\\n            console.log(\\\"tmpTotalAssetValue,perffee,gain = %d,%d,%d\\\",tmpTotalAssetValue,perfFee,gain);\\r\\n            // by definition, tmpTotalAssetValue >= perfFee\\r\\n            levReserve = levReserve + perfFee;\\r\\n            uint updatedNavMantissa = (tmpTotalAssetValue - perfFee)*expScale / totalSupply;  // no need to minus redeemFee here. it's taken away in the final transfer out amt\\r\\n            console.log(\\\"updatedNavMantissa = \\\",updatedNavMantissa);\\r\\n            return updatedNavMantissa;  // only used in minting to determine how many new deptokens to issue\\r\\n        }else{\\r\\n            return navMantissa;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    /**\\r\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n      * @param newPendingAdmin New pending admin.\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\\r\\n        // Check caller = admin\\r\\n        if (msg.sender != admin) {\\r\\n            revert SetPendingAdminOwnerCheck();\\r\\n        }\\r\\n\\r\\n        // Save current value, if any, for inclusion in log\\r\\n        address oldPendingAdmin = pendingAdmin;\\r\\n\\r\\n        // Store pendingAdmin with value newPendingAdmin\\r\\n        pendingAdmin = newPendingAdmin;\\r\\n\\r\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\r\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\r\\n      * @dev Admin function for pending admin to accept role and update admin\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function _acceptAdmin() override external returns (uint) {\\r\\n        // Check caller is pendingAdmin and pendingAdmin  address(0)\\r\\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\r\\n            revert AcceptAdminPendingAdminCheck();\\r\\n        }\\r\\n\\r\\n        // Save current values for inclusion in log\\r\\n        address oldAdmin = admin;\\r\\n        address oldPendingAdmin = pendingAdmin;\\r\\n\\r\\n        // Store admin with value pendingAdmin\\r\\n        admin = pendingAdmin;\\r\\n\\r\\n        // Clear the pending value\\r\\n        pendingAdmin = payable(address(0));\\r\\n\\r\\n        emit NewAdmin(oldAdmin, admin);\\r\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\r\\n     * @param reduceAmount Amount of reduction to reserves\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _reduceReserves(uint reduceAmount) override external nonReentrant returns (uint) {\\r\\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\r\\n        return _reduceReservesFresh(reduceAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reduces reserves by transferring to admin\\r\\n     * @dev Requires fresh interest accrual\\r\\n     * @param reduceAmount Amount of reduction to reserves\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\\r\\n        // totalReserves - reduceAmount\\r\\n        uint levReserveNew;\\r\\n\\r\\n        // Check caller is admin\\r\\n        if (msg.sender != admin) {\\r\\n            revert ReduceReservesAdminCheck();\\r\\n        }\\r\\n\\r\\n        // Fail gracefully if protocol has insufficient underlying cash\\r\\n        if (getCashPrior() < reduceAmount) {\\r\\n            revert ReduceReservesCashNotAvailable();\\r\\n        }\\r\\n\\r\\n        // Check reduceAmount  reserves[n] (totalReserves)\\r\\n        if (reduceAmount > levReserve) {\\r\\n            revert ReduceReservesCashValidation();\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        levReserveNew = levReserve - reduceAmount;\\r\\n\\r\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\r\\n        levReserve = levReserveNew;\\r\\n\\r\\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n        doTransferOut(admin, reduceAmount);\\r\\n\\r\\n        emit ReservesReduced(admin, reduceAmount, levReserveNew);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Sets a new tensorpricer for the market\\r\\n      * @dev Admin function to set a new tensorpricer\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function _setTensorpricer(TensorpricerInterface newTensorpricer) override public returns (uint) {\\r\\n        // Check caller is admin\\r\\n        if (msg.sender != admin) {\\r\\n            revert SetTensorpricerOwnerCheck();\\r\\n        }\\r\\n\\r\\n        TensorpricerInterface oldTensorpricer = tensorpricer;\\r\\n        // Ensure invoke tensorpricer.isTensorpricer() returns true\\r\\n        require(newTensorpricer.isTensorpricer(), \\\"marker method returned false\\\");\\r\\n\\r\\n        // Set market's tensorpricer to newTensorpricer\\r\\n        tensorpricer = newTensorpricer;\\r\\n\\r\\n        // Emit NewTensorpricer(oldTensorpricer, newTensorpricer)\\r\\n        emit NewTensorpricer(oldTensorpricer, newTensorpricer);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    function getCashExReserves() internal view returns (uint) {\\r\\n        uint allCash = getCashPrior();\\r\\n        if(allCash > levReserve){\\r\\n            return allCash - levReserve;\\r\\n        }else{\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    /*** Safe Token ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of the underlying\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of underlying owned by this contract\\r\\n     */\\r\\n    function getCashPrior() virtual internal view returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\r\\n     *  This may revert due to insufficient balance or insufficient allowance.\\r\\n     */\\r\\n    function doTransferIn(address from, uint amount) virtual internal returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\\r\\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\r\\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\r\\n     */\\r\\n    function doTransferOut(address payable to, uint amount) virtual internal;\\r\\n\\r\\n    /*** Reentrancy Guard ***/\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"re-entered\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true; // get a gas-refund post-Istanbul\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/LevTokenInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"./TensorpricerInterface.sol\\\";\\r\\nimport \\\"./InterestRateModel.sol\\\";\\r\\nimport \\\"./DepTokenInterfaces.sol\\\";\\r\\nimport \\\"./EIP20NonStandardInterface.sol\\\";\\r\\nimport \\\"./ErrorReporter.sol\\\";\\r\\nimport \\\"./DepositWithdraw.sol\\\";\\r\\nimport \\\"./CurveSwap.sol\\\";\\r\\n\\r\\ncontract LevTokenStorage {\\r\\n    /**\\r\\n     * @dev protection against contract calling itself (re-entrancy check)\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token name for this token\\r\\n     */\\r\\n    string public name;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token symbol for this token\\r\\n     */\\r\\n    string public symbol;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token decimals for this token, we use 6 to stay consistent with usdc\\r\\n     */\\r\\n    uint8 public decimals;\\r\\n\\r\\n    /**\\r\\n     * @notice Administrator for this contract\\r\\n     */\\r\\n    address payable public admin;\\r\\n\\r\\n    /**\\r\\n     * @notice Pending administrator for this contract\\r\\n     */\\r\\n    address payable public pendingAdmin;\\r\\n\\r\\n    /**\\r\\n     * @notice the brain of this contract\\r\\n     */\\r\\n    TensorpricerInterface public tensorpricer;\\r\\n\\r\\n    /**\\r\\n     * @notice associated depErc20\\r\\n     */\\r\\n    DepErc20Interface public depErc20;\\r\\n\\r\\n    // when totalSupply = 0, need to initialise a NAV\\r\\n    uint internal constant initialNetAssetValueMantissa = 1e18;  // treat like fx rate, 1e18\\r\\n\\r\\n    // when totalSupply = 0, need to initialise a targetLevRatio\\r\\n    uint internal constant initialTargetLevRatio = 5e18;\\r\\n\\r\\n    /**\\r\\n     * @notice Total number of tokens in circulation\\r\\n     */\\r\\n    uint public totalSupply;    // 1e6\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of outstanding borrow in USDT in this market\\r\\n     */\\r\\n    uint public borrowBalanceUSDT;  // in usdt, decimals=6\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of outstanding borrow valued in USDC in this market\\r\\n     */\\r\\n    uint public borrowBalanceUSDC;  // in usdc, decimals=6\\r\\n\\r\\n    /**\\r\\n     * @notice Total asset value in USDC\\r\\n     */\\r\\n    uint public totalAssetValue;  // in usdc, decimals=6\\r\\n\\r\\n    /**\\r\\n     * @notice net asset value in USDC\\r\\n     */\\r\\n    uint public netAssetValue;  // in usdc, BUT decimals=18, asset per levToken\\r\\n\\r\\n    /**\\r\\n     * @notice leverage ratio\\r\\n     */\\r\\n    uint public levRatio;   // 1e18\\r\\n\\r\\n    /**\\r\\n     * @notice\\r\\n     */\\r\\n    uint public extraBorrowDemand;  // in usdt, decimals=6\\r\\n\\r\\n    /**\\r\\n     * @notice\\r\\n     */\\r\\n    uint public extraBorrowSupply;  // in usdt, decimals=6\\r\\n\\r\\n    uint public targetLevRatio; // 1e18\\r\\n\\r\\n    // Official record of token balances for each account\\r\\n    mapping (address => uint) internal accountTokens;\\r\\n\\r\\n    // Approved token transfer amounts on behalf of others\\r\\n    mapping (address => mapping (address => uint)) internal transferAllowances;\\r\\n\\r\\n    // usdc decimals is 6\\r\\n    uint internal constant minTransferAmtUSDC = 50000e6;\\r\\n    uint internal constant thresholdUSDC = 300000e6;\\r\\n    uint internal constant extraUSDC = 100000e6;\\r\\n\\r\\n    struct checkRebalanceRes {\\r\\n        uint res;\\r\\n        uint targetLevRatio;\\r\\n        uint tmpBorrowBalanceUSDC;\\r\\n        uint tmpTotalAssetValue;\\r\\n        uint tmpLevRatio;\\r\\n    }\\r\\n\\r\\n    uint internal hisHighNav;\\r\\n    uint internal levReserve;   // 1e6\\r\\n    uint internal constant redeemFeePC = 1e15;\\r\\n    uint internal constant perfPC = 1e17;\\r\\n\\r\\n    uint internal redeemAmountInUSDC;\\r\\n}\\r\\n\\r\\nabstract contract LevTokenInterface is LevTokenStorage {\\r\\n    /**\\r\\n     * @notice Indicator that this is a LevToken contract (for inspection)\\r\\n     */\\r\\n    bool public constant isLevToken = true;\\r\\n\\r\\n\\r\\n    /*** Market Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are minted\\r\\n     */\\r\\n    event Mint(address minter, uint mintAmount, uint mintTokens, uint nav);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are redeemed\\r\\n     */\\r\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens, uint nav);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when forceRepay is triggered\\r\\n     */\\r\\n    event ForceRepay(address forcer, uint repayAmount);\\r\\n\\r\\n\\r\\n    /*** Admin Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingAdmin is changed\\r\\n     */\\r\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\r\\n     */\\r\\n    event NewAdmin(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tensorpricer is changed\\r\\n     */\\r\\n    event NewTensorpricer(TensorpricerInterface oldTensorpricer, TensorpricerInterface newTensorpricer);\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Transfer event\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint amount);\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Approval event\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserves are reduced\\r\\n     */\\r\\n    event ReservesReduced(address admin, uint reduceAmount, uint newLevReserve);\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function transfer(address dst, uint amount) virtual external returns (bool);\\r\\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\\r\\n    function approve(address spender, uint amount) virtual external returns (bool);\\r\\n    function allowance(address owner, address spender) virtual external view returns (uint);\\r\\n    function balanceOf(address owner) virtual external view returns (uint);\\r\\n    function getNAV(address owner) virtual external view returns (uint);\\r\\n    function getAccountSnapshot(address account) virtual external view returns (uint, uint);\\r\\n    function getCash() virtual external view returns (uint);\\r\\n    function getCompoundBalance() virtual external view returns (uint);\\r\\n    function getLevReserve() virtual external view returns (uint);\\r\\n    function getHisHighNav() virtual external view returns (uint);\\r\\n    \\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);\\r\\n    function _acceptAdmin() virtual external returns (uint);\\r\\n    function _setTensorpricer(TensorpricerInterface newTensorpricer) virtual external returns (uint);\\r\\n    function _reduceReserves(uint reduceAmount) virtual external returns (uint);\\r\\n}\\r\\n\\r\\ncontract LevErc20Storage {\\r\\n    /**\\r\\n     * @notice Underlying asset for this LevToken\\r\\n     */\\r\\n    address public underlying;  // USDC\\r\\n    address public borrowUnderlying;    // USDT\\r\\n}\\r\\n\\r\\nabstract contract LevErc20Interface is LevErc20Storage {\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function getAdmin() virtual external returns (address payable);\\r\\n    function mint(uint mintAmount) virtual external returns (uint);\\r\\n    function redeem(uint redeemTokens) virtual external returns (uint);\\r\\n    function sweepToken(EIP20NonStandardInterface token) virtual external;\\r\\n    function getExtraBorrowDemand() virtual external view returns (uint256);\\r\\n    function getExtraBorrowSupply() virtual external view returns (uint256);\\r\\n    function forceRepay(uint256 repayAmount) virtual external returns (uint);\\r\\n    function updateLedger() virtual external;\\r\\n}\"\r\n    },\r\n    \"contracts/MatrixpricerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nabstract contract MatrixpricerInterface {\\r\\n    /// @notice Indicator that this is a Matrixpricer contract (for inspection)\\r\\n    bool public constant isMatrixpricer = true;\\r\\n\\r\\n    /*** Supported functions ***/\\r\\n    function mintAllowed(address depToken, address minter) virtual external returns (uint);\\r\\n\\r\\n    function redeemAllowed(address depToken, address redeemer, uint redeemTokens) virtual external returns (uint);\\r\\n\\r\\n    function borrowAllowed(address depToken, address borrower) virtual external returns (uint);\\r\\n\\r\\n    function repayBorrowAllowed(\\r\\n        address depToken,\\r\\n        address borrower) virtual external returns (uint);\\r\\n\\r\\n    function transferAllowed(address depToken, address src, address dst, uint transferTokens) virtual external returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TensorpricerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nabstract contract TensorpricerInterface {\\r\\n    /// @notice Indicator that this is a Tensorpricer contract (for inspection)\\r\\n    bool public constant isTensorpricer = true;\\r\\n\\r\\n//    uint public fxMult = 100;   // tmp variable\\r\\n\\r\\n    /*** Supported functions ***/\\r\\n    function mintAllowed(address levToken, address minter) virtual external returns (uint);\\r\\n\\r\\n    function redeemAllowed(address levToken, address redeemer, uint redeemTokens) virtual external returns (uint);\\r\\n\\r\\n    function transferAllowed(address levToken, address src, address dst, uint transferTokens) virtual external returns (uint);\\r\\n\\r\\n    function getFx(string memory fxname) virtual external view returns (uint);\\r\\n\\r\\n    function _setMintPausedLev(address levToken, bool state) virtual public returns (bool);\\r\\n\\r\\n    function _setRedeemPausedLev(address levToken, bool state) virtual public returns (bool);\\r\\n\\r\\n//    function setFxMult(uint mult) virtual external; // tmp function to be removed after testing\\r\\n}\"\r\n    },\r\n    \"contracts/vendor/interfaces/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/vendor/interfaces/IAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IAddressProvider {\\r\\n    // Get the address of the main registry contract.\\r\\n    function get_registry() external view;\\r\\n    function get_address(uint id) external view returns (address);\\r\\n    // function get_id_info(uint id) external view returns (address, bool, uint, uint, string);\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/vendor/interfaces/ICurveFi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface ICurveFi {\\r\\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\\r\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\\r\\n}\"\r\n    },\r\n    \"contracts/vendor/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/vendor/interfaces/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IRegistry {\\r\\n    // Get a list of decimal places for each coin within a pool.\\r\\n    function get_decimals(address pool) external view returns (uint[8] memory);\\r\\n    // Perform an token exchange using a specific pool.\\r\\n    function exchange(address _pool, address _from, address _to, uint _amound, uint _expected, address _receiver) external returns (uint);\\r\\n    // Get the current number of coins received in an exchange.\\r\\n    // Returns the quantity of _to to be received in the exchange.\\r\\n    function get_exchange_amount(address _pool, address _from, address _to, uint _amount) external view returns (uint);\\r\\n}\"\r\n    },\r\n    \"contracts/vendor/interfaces/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n            uint256 newAllowance = oldAllowance - value;\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // function safePermit(\\r\\n    //     IERC20Permit token,\\r\\n    //     address owner,\\r\\n    //     address spender,\\r\\n    //     uint256 value,\\r\\n    //     uint256 deadline,\\r\\n    //     uint8 v,\\r\\n    //     bytes32 r,\\r\\n    //     bytes32 s\\r\\n    // ) internal {\\r\\n    //     uint256 nonceBefore = token.nonces(owner);\\r\\n    //     token.permit(owner, spender, value, deadline, v, r, s);\\r\\n    //     uint256 nonceAfter = token.nonces(owner);\\r\\n    //     require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n    // }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[],\"name\":\"AcceptAdminPendingAdminCheck\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualAddAmount\",\"type\":\"uint256\"}],\"name\":\"AddReservesFactorFreshCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowCashNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"BorrowMatrixpricerRejection\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"LiquidateAccrueBorrowInterestFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"LiquidateAccrueCollateralInterestFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateCloseAmountIsUintMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateCloseAmountIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateCollateralFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateLiquidatorIsBorrower\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"LiquidateMatrixpricerRejection\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"LiquidateRepayBorrowFreshFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateSeizeLiquidatorIsBorrower\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"LiquidateSeizeMatrixpricerRejection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"MintMatrixpricerRejection\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"MintTensorpricerRejection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedeemFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"RedeemMatrixpricerRejection\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"RedeemTensorpricerRejection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedeemTransferOutNotPossible\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReduceReservesAdminCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReduceReservesCashNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReduceReservesCashValidation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReduceReservesFreshCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RepayBorrowFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"RepayBorrowMatrixpricerRejection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetInterestRateModelFreshCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetInterestRateModelOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetMatrixpricerOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetPendingAdminOwnerCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetReserveFactorAdminCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetReserveFactorBoundsCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetReserveFactorFreshCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetTensorpricerOwnerCheck\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"TransferMatrixpricerRejection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferNotEnough\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferNotEnoughAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"TransferTensorpricerRejection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferTooMuch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"forcer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"ForceRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nav\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract TensorpricerInterface\",\"name\":\"oldTensorpricer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract TensorpricerInterface\",\"name\":\"newTensorpricer\",\"type\":\"address\"}],\"name\":\"NewTensorpricer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nav\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLevReserve\",\"type\":\"uint256\"}],\"name\":\"ReservesReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADDRESSPROVIDER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NO_ERROR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TriPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"}],\"name\":\"_reduceReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TensorpricerInterface\",\"name\":\"newTensorpricer\",\"type\":\"address\"}],\"name\":\"_setTensorpricer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowBalanceUSDC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowBalanceUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowUnderlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkRebalanceExt\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetLevRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tmpBorrowBalanceUSDC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tmpTotalAssetValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tmpLevRatio\",\"type\":\"uint256\"}],\"internalType\":\"struct LevTokenStorage.checkRebalanceRes\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depErc20\",\"outputs\":[{\"internalType\":\"contract DepErc20Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doRebalanceExt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraBorrowDemand\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraBorrowSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"repayAmountInUSDT\",\"type\":\"uint256\"}],\"name\":\"forceRepay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCmpUSDTExchRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCmpUSDTSupplyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCompoundBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExtraBorrowDemand\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExtraBorrowSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHisHighNav\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLevReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getNAV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowUnderlying_\",\"type\":\"address\"},{\"internalType\":\"contract TensorpricerInterface\",\"name\":\"tensorpricer_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLevToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"levRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"netAssetValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prologue\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fx_USDTUSDC_Mantissa\",\"type\":\"uint256\"}],\"name\":\"refreshTargetLevRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"compoundV2cUSDCAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"compoundV2cUSDTAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"USDCAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"USDTAddress_\",\"type\":\"address\"}],\"name\":\"setAddressesForCompound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TriPool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ADDRESSPROVIDER_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"USDC_ADDRESS_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"USDT_ADDRESS_\",\"type\":\"address\"}],\"name\":\"setAddressesForCurve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DepErc20Interface\",\"name\":\"depErc20_\",\"type\":\"address\"}],\"name\":\"setDepErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setPrologue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract EIP20NonStandardInterface\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetLevRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tensorpricer\",\"outputs\":[{\"internalType\":\"contract TensorpricerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssetValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateLedger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "LevErc20",
    "CompilerVersion": "v0.8.15+commit.e14f2714",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}